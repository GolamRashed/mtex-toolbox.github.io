
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <title>Functions - Alphabetical List (MTEX Toolbox)
         
      </title>
      <!-- DOCNAME: MTEX Toolbox -->
      <meta name="chunktype" content="refpage">
      <!-- CHUNKNAME:  -->
      <!-- HEADSTUFF:  -->
      <!-- HEADSTUFF -->
      <meta name="refentity" content="method:">
      <meta http-equiv="Content-Script-Type" content="text/javascript">
      <meta name="toctype" content="fcn">
      <link rel="stylesheet" href="style.css"><script language="JavaScript" src="docscripts.js"></script></head>
   <body><a name="top_of_page"></a><div>
         <table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0">
            <tr>
               <td valign="baseline"><b>MTEX</b> - A MATLAB Toolbox for Quantitative Texture Analysis</td>
            </tr>
         </table>
         <p style="font-size:1px;"></p>
      </div>
      <div class="content">
         <h1 class="refname">Functions - Alphabetical List</h1>
         <div class="subheading">
            <div class="funcrefpage"><a href="funcref_cat.html">&gt;&gt; Categorial List</a></div><span> <a href="#1">A</a></span><span> <a href="#2">B</a></span><span> <a href="#3">C</a></span><span> <a href="#4">D</a></span><span> <a href="#5">E</a></span><span> <a href="#6">F</a></span><span> <a href="#7">G</a></span><span> <a href="#8">H</a></span><span> <a href="#9">I</a></span><span> J</span><span> <a href="#10">K</a></span><span> <a href="#11">L</a></span><span> <a href="#12">M</a></span><span> <a href="#13">N</a></span><span> <a href="#14">O</a></span><span> <a href="#15">P</a></span><span> <a href="#16">Q</a></span><span> <a href="#17">R</a></span><span> <a href="#18">S</a></span><span> <a href="#19">T</a></span><span> <a href="#20">U</a></span><span> <a href="#21">V</a></span><span> <a href="#22">W</a></span><span> <a href="#23">X</a></span><span> <a href="#24">Y</a></span><span> <a href="#25">Z</a></span></div>
         <h2>A<a name="1"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="vector3d.abs.html"><tt>abs</tt></a><span>   (vector3d)</span></td>
            <td>length of vector</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.adjustFigurePosition.html"><tt>adjustFigurePosition</tt></a><span>   (mtexFigure)</span></td>
            <td>determine optimal size</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.affinetrans.html"><tt>affinetrans</tt></a><span>   (EBSD)</span></td>
            <td>perform an affine transformation on spatial ebsd data  Input ebsd - @EBSD A    - transformation matrix or homogeneous
               coordinates, e.g.   [1 0;0 1]  or  [1 0 dy; 0 1 dx; 0 0 1 ]  b    - shift term  Output transformed ebsd - @EBSD
            </td>
            <tr></tr>
            <td width="250px"><a href="symmetry.alignment.html"><tt>alignment</tt></a><span>   (symmetry)</span></td>
            <td>return alignment of the reference frame as string, e.g. x||a, y||b*</td>
            <tr></tr>
            <td width="250px"><a href="allPairs.html"><tt>allPairs</tt></a></td>
            <td>all pairs of elements of x and y modulo permutation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.angle.html"><tt>angle</tt></a><span>   (orientation)</span></td>
            <td>calculates rotational angle between orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.angle.html"><tt>angle</tt></a><span>   (quaternion)</span></td>
            <td>calcualtes the rotational angle between rotations q1 and q2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.angle.html"><tt>angle</tt></a><span>   (vector3d)</span></td>
            <td>angle between two vectors Input v1, v2 - @vector3d</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.angle_outer.html"><tt>angle_outer</tt></a><span>   (quaternion)</span></td>
            <td>calcualtes the rotational angle between all rotations q1 and q2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.angle_outer.html"><tt>angle_outer</tt></a><span>   (vector3d)</span></td>
            <td>angle between two vectors</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.angleDistribution.html"><tt>angleDistribution</tt></a><span>   (orientationRegion)</span></td>
            <td>compute the angle distribution of a uniform ODF for a crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.angleDistribution.html"><tt>angleDistribution</tt></a><span>   (symmetry)</span></td>
            <td>compute the angle distribution of a uniform ODF for a crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="annotate.html"><tt>annotate</tt></a></td>
            <td>annotate to a existing figure</td>
            <tr></tr>
            <td width="250px"><a href="apply_recursivly.html"><tt>apply_recursivly</tt></a></td>
            <td>apply cmd recursively to all file in a directory</td>
            <tr></tr>
            <td width="250px"><a href="ar2rgb.html"><tt>ar2rgb</tt></a></td>
            <td>compute rgb values from angle and radius</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.area.html"><tt>area</tt></a><span>   (grain2d)</span></td>
            <td>calculates the area of a list of grains  Input grains - @grain2d  Output A  - list of areas</td>
            <tr></tr>
            <td width="250px"><a href="argin_check.html"><tt>argin_check</tt></a></td>
            <td>check ar to be of class classes</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.arrow3d.html"><tt>arrow3d</tt></a><span>   (vector3d)</span></td>
            <td>plot three dimensional arrows</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.aspectRatio.html"><tt>aspectRatio</tt></a><span>   (grain2d)</span></td>
            <td>calculates the aspectratio of grain  the aspect ratio is the ratio between the two &lt;grain2d.principalcomponents.html,principal
               componentes&gt; of a grain  Input g - @grain2d  Output asp   - aspect--ratio  See also grain2d/principalcomponents
            </td>
            <tr></tr>
            <td width="250px"><a href="assert_grid.html"><tt>assert_grid</tt></a></td>
            <td>check for valid grid parameters</td>
            <tr></tr>
            <td width="250px"><a href="assertExt.html"><tt>assertExt</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.axesDual.html"><tt>axesDual</tt></a><span>   (crystalSymmetry)</span></td>
            <td>return dual coordinate axes</td>
            <tr></tr>
            <td width="250px"><a href="orientation.axis.html"><tt>axis</tt></a><span>   (orientation)</span></td>
            <td>rotational axis of an misorientation or two orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.axis.html"><tt>axis</tt></a><span>   (quaternion)</span></td>
            <td>rotational axis of the quaternion</td>
            <tr></tr>
            <td width="250px"><a href="axis2quat.html"><tt>axis2quat</tt></a></td>
            <td>rotational axis, roational angle to Quaternion</td>
            <tr></tr>
            <td width="250px"><a href="axis2quat_outer.html"><tt>axis2quat_outer</tt></a></td>
            <td>rotational axis, roational angle to Quaternion</td>
            <tr></tr>
            <td width="250px"><a href="axisAngleSections.html"><tt>axisAngleSections</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.axisSector.html"><tt>axisSector</tt></a><span>   (orientationRegion)</span></td>
            <td>computes the sector of rotational axes for orientations within region</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>B<a name="2"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="FourierComponent.bandwidth.html"><tt>bandwidth</tt></a><span>   (FourierComponent)</span></td>
            <td>bandwidth of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.bandwidth.html"><tt>bandwidth</tt></a><span>   (ODF)</span></td>
            <td>bandwidth of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.bandwidth.html"><tt>bandwidth</tt></a><span>   (ODFComponent)</span></td>
            <td>bandwidth of the component</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.bandwidth.html"><tt>bandwidth</tt></a><span>   (fibreComponent)</span></td>
            <td>bandwidth of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.bandwidth.html"><tt>bandwidth</tt></a><span>   (uniformComponent)</span></td>
            <td>bandwidth of the component</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.bandwidth.html"><tt>bandwidth</tt></a><span>   (unimodalComponent)</span></td>
            <td>bandwidth of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.BCV.html"><tt>BCV</tt></a><span>   (orientation)</span></td>
            <td>biased cross validation</td>
            <tr></tr>
            <td width="250px"><a href="binary_search.html"><tt>binary_search</tt></a></td>
            <td>searches for y in x</td>
            <tr></tr>
            <td width="250px"><a href="orientation.bingham_test.html"><tt>bingham_test</tt></a><span>   (orientation)</span></td>
            <td>bingham test for spherical/prolat/oblat case  Input ori      - @orientation  Options spherical - test case prolate
                  - oblate     -  c_hat     - test without kappas  See also evalkappa c_hat
            </td>
            <tr></tr>
            <td width="250px"><a href="BinghamODF.html"><tt>BinghamODF</tt></a></td>
            <td>defines a Bingham distributed ODF</td>
            <tr></tr>
            <td width="250px"><a href="binsearch.html"><tt>binsearch</tt></a></td>
            <td>binaer search for zero in a motonously increasing function</td>
            <tr></tr>
            <td width="250px"><a href="black2whiteColorMap.html"><tt>black2whiteColorMap</tt></a></td>
            <td>Linear white to black gray-scale color map</td>
            <tr></tr>
            <td width="250px"><a href="blue2redColorMap.html"><tt>blue2redColorMap</tt></a></td>
            <td>creates a colormap, ranging from dark blue via white to dark red.</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.boundary.html"><tt>boundary</tt></a><span>   (sphericalRegion)</span></td>
            <td>compute boundary points</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.boundarySize.html"><tt>boundarySize</tt></a><span>   (grain2d)</span></td>
            <td>number of boundary segment  Input grains - @grain2d  Output bS - number of boundary segment  Syntax peri = grains.boundarySize</td>
            <tr></tr>
            <td width="250px"><a href="brassOrientation.html"><tt>brassOrientation</tt></a></td>
            <td>returns the cube orientation</td>
            <tr></tr>
            <td width="250px"><a href="bucketSearch.html"><tt>bucketSearch</tt></a></td>
            <td>n-d search of the closest vertex out of a set of vertices V</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>C<a name="3"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="c_hat.html"><tt>c_hat</tt></a></td>
            <td>return the second moments for bingham test  Input o   -  @EBSD / @orientation / @grain  Output chat  - 4x4 tensor 
               T     - eigenvalues Tv    - eigenvectors n     - number of points  See also bingham_test
            </td>
            <tr></tr>
            <td width="250px"><a href="calc_flags.html"><tt>calc_flags</tt></a></td>
            <td>check for optional flag</td>
            <tr></tr>
            <td width="250px"><a href="misorientationAnalysis.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a><span>   (misorientationAnalysis)</span></td>
            <td>calculate angle distribution   Input ebsd   - @EBSD grains - @grainSet  Flags  Output density - the density, such
               that   $$\int f(\omega) d\omega = \pi$$  omega   - interval of density  See also EBSD/calcMisorientation misorientationAnalysis/plotAngleDistribution
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a><span>   (ODF)</span></td>
            <td>compute the angle distribution of an ODF or an MDF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a><span>   (orientation)</span></td>
            <td>calculate angle distribution  Input ori   - @orientation  Flags  Output density - the density normalized such that
               sum(density)=100 omega   - corresponding list of misorientation angles  See also EBSD/calcMisorientation misorientationAnalysis/plotAngleDistribution
            </td>
            <tr></tr>
            <td width="250px"><a href="misorientationAnalysis.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a><span>   (misorientationAnalysis)</span></td>
            <td>calculate axis distribution  Input ebsd   - @EBSD grains - @grainSet  Flags  Output  See also EBSD/calcMisorientation
               EBSD/plotAngleDistribution
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a><span>   (ODF)</span></td>
            <td>compute the axis distribution of an ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a><span>   (orientationRegion)</span></td>
            <td>compute the axis distribution of an uniform ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a><span>   (symmetry)</span></td>
            <td>compute the axis distribution of an uniform ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAxisVolume.html"><tt>calcAxisVolume</tt></a><span>   (ODF)</span></td>
            <td>compute the axis distribution of an ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.calcBario.html"><tt>calcBario</tt></a><span>   (DelaunaySO3)</span></td>
            <td>compute bariocentric coordinates for an orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcBinghamODF.html"><tt>calcBinghamODF</tt></a><span>   (orientation)</span></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcDelaunay.html"><tt>calcDelaunay</tt></a><span>   (vector3d)</span></td>
            <td>compute the Delaynay triangulation for a spherical grid</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcError.html"><tt>calcError</tt></a><span>   (ODF)</span></td>
            <td>calculate approximation error between two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcError.html"><tt>calcError</tt></a><span>   (PoleFigure)</span></td>
            <td>RP and mean square error</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcErrorPF.html"><tt>calcErrorPF</tt></a><span>   (PoleFigure)</span></td>
            <td>error polefigure between meassured and recalculated pole figures</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcFEMODF.html"><tt>calcFEMODF</tt></a><span>   (PoleFigure)</span></td>
            <td>PDF to ODF inversion</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (BinghamComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (FourierComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcFourier.html"><tt>calcFourier</tt></a><span>   (ODF)</span></td>
            <td>compute Fourier coefficients of odf</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (femComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (fibreComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (uniformComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (unimodalComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcFourierODF.html"><tt>calcFourierODF</tt></a><span>   (orientation)</span></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcGrains.html"><tt>calcGrains</tt></a><span>   (EBSD)</span></td>
            <td>2d and 3d construction of GrainSets from spatially indexed EBSD data  Syntax grains = calcGrains(ebsd,'angle',10*degree)
                Input ebsd   - @EBSD  Output grains  - @Grain2d | @Grain3d  Options threshold|angle - array of threshold angles per
               phase of mis/disorientation in radians boundary        - bounds the spatial domain  Flags unitcell     - omit voronoi
               decomposition and treat a unitcell lattice  See also GrainSet/GrainSet
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcKernel.html"><tt>calcKernel</tt></a><span>   (orientation)</span></td>
            <td>compute an optimal kernel function for ODF estimation  Input ori - @orientation  Output psi    - @kernel  Options
               method  - select a halfwidth by  * |'RuleOfThumb'|   or via cross valiadation method:  * |'LSCV'| -- least squares cross
               valiadation * |'KLCV'| -- Kullback Leibler cross validation * |'BCV'| -- biased cross validation  See also EBSD/calcODF
               orientation/BCV orientation/KLCV orientation/LSCV
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcKernelODF.html"><tt>calcKernelODF</tt></a><span>   (orientation)</span></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="misorientationAnalysis.calcMDF.html"><tt>calcMDF</tt></a><span>   (misorientationAnalysis)</span></td>
            <td>calculate misorientation distribution function  Input  ebsd   - @EBSD grains - @GrainSet  Output mdf - @ODF MDF 
               See also
            </td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcMDF.html"><tt>calcMDF</tt></a><span>   (FourierComponent)</span></td>
            <td>calculate the uncorrelated misorientation distribution function (MDF) from one or two ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcMDF.html"><tt>calcMDF</tt></a><span>   (ODF)</span></td>
            <td>calculate the uncorrelated misorientation distribution function (MDF) from one or two ODF</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcMDF.html"><tt>calcMDF</tt></a><span>   (unimodalComponent)</span></td>
            <td>calculate the uncorrelated misorientation distribution function (MDF) from one or two ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcMDF.html"><tt>calcMDF</tt></a><span>   (orientation)</span></td>
            <td>computes an MDF from individuel orientations</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcMIndex.html"><tt>calcMIndex</tt></a><span>   (ODF)</span></td>
            <td>M-index of Skemer et al.(2005) based on the difference between uncorrelated and uniform misorientation angle distributions
                Reference Skemer, P., Katayama, I., Jiang, Z. &amp; Karato, S.-I. (2005) The misorientation index: development of a new method
               for calculating the strength of latticepreferred orientation. Tectonophysics, 411, 157?167.  Reference for the computational
               method using MTEX Mainprice, D., Bachmann, F., Hielscher, R., Schaeben, H. (2014) Descriptive tools for the analysis of
               texture projects with large datasets using MTEX: strength, symmetry and components. In: Faulkner, D. R., Mariani, E. &amp; Mecklenburgh,
               J. (eds) Rock Deformation from Field, Experiments and Theory: A Volume in Honour of Ernie Rutter. Geological Society, London,
               Special Publications, 409, http://dx.doi.org/10.1144/SP409.8  Input odf = @odf  Output MI = M-index  David Mainprice
               04/01/2015
            </td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcMisorientation.html"><tt>calcMisorientation</tt></a><span>   (EBSD)</span></td>
            <td>calculate uncorelated misorientations between two ebsd phases  Input  ebsd - @EBSD  Output m - @orientation, such that
                $$m = (g{_i}^{--1}*CS^{--1}) * (CS *\circ g_j)$$  for two neighbored orientations $g_i, g_j$ with crystal @symmetry $CS$
               of  the same phase located on a grain boundary.  See also
            </td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.calcModes.html"><tt>calcModes</tt></a><span>   (BinghamComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcModes.html"><tt>calcModes</tt></a><span>   (ODF)</span></td>
            <td>heuristic to find modal orientations  Syntax [modes, values] = calcModes(odf,n)  Input odf - @ODF  n   - number of
               modes  Output modes - modal @orientation values - values of the ODF at the modal @orientation  Options resolution 
               - search--grid resolution accuracy    - in radians  Example find the local maxima of the [[SantaFe.html,SantaFe]] ODF
                mode = calcModes(SantaFe) plotPDF(SantaFe,Miller(0,0,1)) annotate(mode)  See also ODF/max
            </td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.calcModes.html"><tt>calcModes</tt></a><span>   (ODFComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.calcModes.html"><tt>calcModes</tt></a><span>   (fibreComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcModes.html"><tt>calcModes</tt></a><span>   (unimodalComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcNormalization.html"><tt>calcNormalization</tt></a><span>   (PoleFigure)</span></td>
            <td>normalization of a meassured pole figure with respect to a second pole figure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcODF.html"><tt>calcODF</tt></a><span>   (PoleFigure)</span></td>
            <td>PDF to ODF inversion</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcODF.html"><tt>calcODF</tt></a><span>   (orientation)</span></td>
            <td>computes an ODF from individuel orientations</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcOrientations.html"><tt>calcOrientations</tt></a><span>   (ODF)</span></td>
            <td>draw random orientations from ODF</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (BinghamComponent)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (FourierComponent)</span></td>
            <td>calculate pole figure from Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcPDF.html"><tt>calcPDF</tt></a><span>   (ODF)</span></td>
            <td>calculate pdf</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (femComponent)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (fibreComponent)</span></td>
            <td>calculate pdf for fibre component</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (uniformComponent)</span></td>
            <td>calculate pdf</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (unimodalComponent)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcpdf_special.html"><tt>calcpdf_special</tt></a><span>   (FourierComponent)</span></td>
            <td>compute the pdf for h = (theta,rhoh), r = (theta,rhor)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcpdf_special3.html"><tt>calcpdf_special3</tt></a><span>   (ODF)</span></td>
            <td>compute the pdf for h = (theta,rhoh), r = (theta,rhor)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcPoleFigure.html"><tt>calcPoleFigure</tt></a><span>   (ODF)</span></td>
            <td>simulate pole figures from an ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcPoleFigure.html"><tt>calcPoleFigure</tt></a><span>   (PoleFigure)</span></td>
            <td>simulate pole figure</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcQuadratureWeights.html"><tt>calcQuadratureWeights</tt></a><span>   (vector3d)</span></td>
            <td>compute the area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcQuat.html"><tt>calcQuat</tt></a><span>   (symmetry)</span></td>
            <td>calculate quaternions for Laue groups</td>
            <tr></tr>
            <td width="250px"><a href="tensor.calcShearStress.html"><tt>calcShearStress</tt></a><span>   (tensor)</span></td>
            <td>shear stress</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcTensor.html"><tt>calcTensor</tt></a><span>   (EBSD)</span></td>
            <td>compute the average tensor for an EBSD data set  Syntax [TVoigt, TReuss, THill] = calcTensor(ebsd,T_phase1,T_phase2,...)
               - returns the Voigt--, Reuss-- and Hill-- @tensor, applies each tensor given in order of input to each phase  [TVoigt,
               TReuss, THill] = calcTensor(ebsd('phase2'),T_phase2) - returns the Voigt--, Reuss-- and Hill-- @tensor, applies a tensor
               on a given phase  THill = calcTensor(ebsd,T_phase1,T_phase2,'Hill') - returns the specified @tensor, i.e. 'Hill' in this
               case  TVoigt = calcTensor(ebsd,T_phase1,T_phase2,'geometricMean') - use geometric mean instead of arithmetric one  Input
               ebsd     - @EBSD T_phaseN - @tensor for the N--th phase  Output T    - @tensor  Options Voigt - voigt mean Reuss -
               reuss mean Hill  - hill mean  See also
            </td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcTensor.html"><tt>calcTensor</tt></a><span>   (FourierComponent)</span></td>
            <td>compute the average tensor for an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcTensor.html"><tt>calcTensor</tt></a><span>   (ODF)</span></td>
            <td>compute the average tensor for an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.calcTensor.html"><tt>calcTensor</tt></a><span>   (ODFComponent)</span></td>
            <td>compute the average tensor for an ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcTensor.html"><tt>calcTensor</tt></a><span>   (orientation)</span></td>
            <td>compute the average tensor for a vector of orientations  Syntax %returns the Voigt--, Reuss-- and Hill-- average @tensor
               of T [TVoigt, TReuss, THill] = calcTensor(ori,T,'weights',w) -   % returns the specified @tensor, i.e. 'Hill' in this case
               THill = calcTensor(ori,T,'Hill')  % uses geometric mean instead of arithmetric one TVoigt = calcTensor(ori,T,'geometricMean')
                Input ori     - @orientation T       - @tensor w       - weights for each orientation  Output TVoigt, TReuss, THill
               - @tensor  Options Voigt - voigt mean Reuss - reuss mean Hill  - hill mean  See also
            </td>
            <tr></tr>
            <td width="250px"><a href="calcUnitCell.html"><tt>calcUnitCell</tt></a></td>
            <td>compute the unit cell for an EBSD data set  Input xy - spatial coordinates  Output unitCell - coordinates of the unit
               cell  Options  GridType - [automatic, hexagonal, rectangular]
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.calcVoronoi.html"><tt>calcVoronoi</tt></a><span>   (quaternion)</span></td>
            <td>compute the the Voronoi decomposition for unit quaternions  Input q - @quaternion  Output V - Voronoi--Vertices C -
               Voronoi--Cells containing the index to the Voronoi--Vertex  See also S2Grid\calcVoronoi voronoin
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcVoronoi.html"><tt>calcVoronoi</tt></a><span>   (vector3d)</span></td>
            <td>compute the area of the Voronoi decomposition  Input v - @vector3d  Output V - list of Voronoi--Vertices C - cell array
               of Voronoi--Vertices per generator  See also voronoin
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcVoronoiArea.html"><tt>calcVoronoiArea</tt></a><span>   (vector3d)</span></td>
            <td>compute the area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="call_extern.html"><tt>call_extern</tt></a></td>
            <td>execute extern program with arguments  Syntax varargout = call_extern(prg,variable_name,variable_value,...,flags,....)
                Input prg            - command to be executed varaiable_name - name of a variable varaiable_name - value of a variable
                Flags SILENT VERBOSE EXTERN INTERN  Output varagout - list of output parameters
            </td>
            <tr></tr>
            <td width="250px"><a href="EBSD.cat.html"><tt>cat</tt></a><span>   (EBSD)</span></td>
            <td>overloads [ebsd1,ebsd2,ebsd3..]</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.cat.html"><tt>cat</tt></a><span>   (grain2d)</span></td>
            <td>concatenation of grains from the same GrainSet  Syntax g = [grains_1, grains_2, grains_n]  Example g = [grains('fe')
               grains('mg')] g = [grains(1:100) grains(500:end)]  See also GrainSet/vertcat
            </td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.cat.html"><tt>cat</tt></a><span>   (PoleFigure)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="Miller.cat.html"><tt>cat</tt></a><span>   (Miller)</span></td>
            <td>concatenate lists of Miller indices to one list</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.cat.html"><tt>cat</tt></a><span>   (S2Grid)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.cat.html"><tt>cat</tt></a><span>   (quaternion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="rotation.cat.html"><tt>cat</tt></a><span>   (rotation)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cat.html"><tt>cat</tt></a><span>   (vector3d)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="cell2file.html"><tt>cell2file</tt></a></td>
            <td>write cellstring to file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.centerSpecimen.html"><tt>centerSpecimen</tt></a><span>   (ODF)</span></td>
            <td>rotatates an odf with specimen symmetry into its symmetry axes  centerSpecimen(odf,center) trys to find the normal vectors
               of orthorhombic symmetry for the x mirror and y mirror plane and calculates an rotation needed to rotate the odf back into
               these mirror planes. the routine starts with an lookaround grid for a given center (default xvector) to find a starting
               value for newton iteration.  Input odf - @ODF v0  - @vector3d initial gues for a symmetry axis (default xvector)  Output
               odf    - rotated @ODF rot    - @rotation such that rotate(odf_out,r) = odf_in v1,v2  - normal vector of the two fold symmetry
               axes  Options SO3Grid    - a @SO3Grid the @ODF is evaluatete on delta      - specifies the opening angle for the initial
               search grid around input center resolution - specifies the resolution for the initial search grid silent     - dont verbose
               number of initial axes and the newton iteration  fourier    - use fourier coefficents as objective function  Example:
               Starting with an synthetic odf with orthorhombic symmetry  CS = crystalSymmetry('cubic') SS = specimenSymmetry('orthorhombic')
               h = [Miller(0,0,1),Miller(0,1,1),Miller(1,1,1)]; r = [ rotation('euler', 90*degree,35*degree,30*degree) ... rotation('euler',
               90*degree,35*degree,0*degree)]  sr = SS*r; odf = unimodalODF(sr,CS);  we define a rotational displacement  r2 = rotation('euler',
               6*degree,4*degree,0*degree) odf = rotate(odf,r2);  plotPDF(odf,h,'antipodal');  and now retrive the rotation back 
               [odr,r,v1,v2] = centerSpecimen(odf); plotPDF(odr,h,'antipodal')
            </td>
            <tr></tr>
            <td width="250px"><a href="grain2d.centroid.html"><tt>centroid</tt></a><span>   (grain2d)</span></td>
            <td>calculates the barycenters of the grain polygons</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.char.html"><tt>char</tt></a><span>   (EBSD)</span></td>
            <td>ebsd -&gt; char</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.char.html"><tt>char</tt></a><span>   (PoleFigure)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="Miller.char.html"><tt>char</tt></a><span>   (Miller)</span></td>
            <td>Miller indece to string</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.char.html"><tt>char</tt></a><span>   (SO3Grid)</span></td>
            <td>convert to char</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.char.html"><tt>char</tt></a><span>   (crystalSymmetry)</span></td>
            <td>object -&gt; string</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.char.html"><tt>char</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to char</td>
            <tr></tr>
            <td width="250px"><a href="rotation.char.html"><tt>char</tt></a><span>   (rotation)</span></td>
            <td>quaternion to char</td>
            <tr></tr>
            <td width="250px"><a href="specimenSymmetry.char.html"><tt>char</tt></a><span>   (specimenSymmetry)</span></td>
            <td>object -&gt; string</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.char.html"><tt>char</tt></a><span>   (sphericalRegion)</span></td>
            <td>convert spherical region to char</td>
            <tr></tr>
            <td width="250px"><a href="tensor.char.html"><tt>char</tt></a><span>   (tensor)</span></td>
            <td>tensor to char</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.char.html"><tt>char</tt></a><span>   (vector3d)</span></td>
            <td>convert to char</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.ChebCoeff.html"><tt>ChebCoeff</tt></a><span>   (FourierComponent)</span></td>
            <td>return Chebyshev coefficient of odf</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.check.html"><tt>check</tt></a><span>   (DelaunaySO3)</span></td>
            <td>ignore this</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.check.html"><tt>check</tt></a><span>   (symmetry)</span></td>
            <td>check symmetry</td>
            <tr></tr>
            <td width="250px"><a href="check_installation.html"><tt>check_installation</tt></a></td>
            <td>check whether all binaries are working properly</td>
            <tr></tr>
            <td width="250px"><a href="check_interfaces.html"><tt>check_interfaces</tt></a></td>
            <td>determine interface from file</td>
            <tr></tr>
            <td width="250px"><a href="check_option.html"><tt>check_option</tt></a></td>
            <td>check for option in option list</td>
            <tr></tr>
            <td width="250px"><a href="checkEulerAngleConvention.html"><tt>checkEulerAngleConvention</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="Miller.checkFundamentalRegion.html"><tt>checkFundamentalRegion</tt></a><span>   (Miller)</span></td>
            <td>checks Miller indice to be within the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="orientation.checkFundamentalRegion.html"><tt>checkFundamentalRegion</tt></a><span>   (orientation)</span></td>
            <td>checks whether a orientation sits within the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.checkInside.html"><tt>checkInside</tt></a><span>   (orientationRegion)</span></td>
            <td>check for points to be inside the orientation region</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.checkInside.html"><tt>checkInside</tt></a><span>   (sphericalRegion)</span></td>
            <td>check for points to be inside the spherical region</td>
            <tr></tr>
            <td width="250px"><a href="checkOption.html"><tt>checkOption</tt></a></td>
            <td>check for option in option list</td>
            <tr></tr>
            <td width="250px"><a href="tensor.checkSymmetry.html"><tt>checkSymmetry</tt></a><span>   (tensor)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="tensor.ChristoffelTensor.html"><tt>ChristoffelTensor</tt></a><span>   (tensor)</span></td>
            <td>Christoffel tensor of an elasticity tensor for a given direction</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.circle.html"><tt>circle</tt></a><span>   (vector3d)</span></td>
            <td>annotated a circle  Input n     - a normal @vector3d omega - an opening angle around n (default pi/2) (GreatCircle) an
               @vector3d  Options
            </td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.cleanUp.html"><tt>cleanUp</tt></a><span>   (orientationRegion)</span></td>
            <td>testing: cs = crystalSymmetry('222'); oR = cs.fundamentalRegion;</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.cleanUp.html"><tt>cleanUp</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="ClebschGordan.html"><tt>ClebschGordan</tt></a></td>
            <td>ClebschGordan.m by David Terr, Raytheon, 6-17-04 Modified on 11-9-04</td>
            <tr></tr>
            <td width="250px"><a href="ClebschGordanTensor.html"><tt>ClebschGordanTensor</tt></a></td>
            <td>A = [[1 1 -1];[1 1 1];[-1 1 1]];</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.CLim.html"><tt>CLim</tt></a><span>   (mtexFigure)</span></td>
            <td>set color range for figures</td>
            <tr></tr>
            <td width="250px"><a href="clusterBreaker.html"><tt>clusterBreaker</tt></a></td>
            <td>Recursively assigns points based on neighboring assignments If flag == 0, the point is fresh,  1, the point is set &gt;1,
               the point belongs to a cluster that may have run into the recusion limit
            </td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.coarser.html"><tt>coarser</tt></a><span>   (S1Grid)</span></td>
            <td>makes S1Grid more coarse</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.colorbar.html"><tt>colorbar</tt></a><span>   (mtexFigure)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="ODF.concentration.html"><tt>concentration</tt></a><span>   (ODF)</span></td>
            <td>not yet implemeted</td>
            <tr></tr>
            <td width="250px"><a href="tensor.conj.html"><tt>conj</tt></a><span>   (tensor)</span></td>
            <td>conjugate of a tensor  Input T - @tensor  Output T - @tensor</td>
            <tr></tr>
            <td width="250px"><a href="connectedComponents.html"><tt>connectedComponents</tt></a></td>
            <td>label connected componentes in an graph (adjacency matrix)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.contour.html"><tt>contour</tt></a><span>   (vector3d)</span></td>
            <td>spherical contour plot  Syntax contour(v,data)  Input v - @vector3d data - double  Options contours - number of
               contours  See also vector3d/plot vector3d/contourf
            </td>
            <tr></tr>
            <td width="250px"><a href="contour3s.html"><tt>contour3s</tt></a></td>
            <td>contour-slices</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.contourf.html"><tt>contourf</tt></a><span>   (vector3d)</span></td>
            <td>spherical filled contour plot  Syntax contourf(v,data)  Input v - @vector3d data - double  Options contours - number
               of contours  See also vector3d/plot vector3d/contour
            </td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.conv.html"><tt>conv</tt></a><span>   (FourierComponent)</span></td>
            <td>convolute ODF with kernel psi</td>
            <tr></tr>
            <td width="250px"><a href="ODF.conv.html"><tt>conv</tt></a><span>   (ODF)</span></td>
            <td>convolute ODF with kernel psi</td>
            <tr></tr>
            <td width="250px"><a href="convertFigureRGB2ind.html"><tt>convertFigureRGB2ind</tt></a></td>
            <td>default resolution</td>
            <tr></tr>
            <td width="250px"><a href="coolColorMap.html"><tt>coolColorMap</tt></a></td>
            <td>COOL   Shades of cyan and magenta color map COOL(M) returns an M-by-3 matrix containing a "cool" colormap. COOL, by itself,
               is the same length as the current figure's colormap. If no figure exists, MATLAB creates one.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.copy.html"><tt>copy</tt></a><span>   (S2Grid)</span></td>
            <td>copy certain condition from grid</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.copy.html"><tt>copy</tt></a><span>   (SO3Grid)</span></td>
            <td>copy nodes by indece</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.correct.html"><tt>correct</tt></a><span>   (PoleFigure)</span></td>
            <td>corrects polfigures for background and defocussing</td>
            <tr></tr>
            <td width="250px"><a href="cprproject_read.html"><tt>cprproject_read</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.cross.html"><tt>cross</tt></a><span>   (quaternion)</span></td>
            <td>pointwise cross product of three quaternions  Input q1,q2,q3 - @quaternion  Output @quaternion</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cross.html"><tt>cross</tt></a><span>   (vector3d)</span></td>
            <td>pointwise cross product of two vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cross_outer.html"><tt>cross_outer</tt></a><span>   (vector3d)</span></td>
            <td>pointwise cross product of two vector3d</td>
            <tr></tr>
            <td width="250px"><a href="orientation.crossCorrelation.html"><tt>crossCorrelation</tt></a><span>   (orientation)</span></td>
            <td>computes the cross correlation for the kernel density estimator</td>
            <tr></tr>
            <td width="250px"><a href="CSL.html"><tt>CSL</tt></a></td>
            <td>coincidence site lattice misorientations for cubic symmetry  Syntax q = CSL(sigma)  Options delta    - search radius
               around angle or axis maxsigma -   Output  o - @orientation
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ctranspose.html"><tt>ctranspose</tt></a><span>   (quaternion)</span></td>
            <td>transpose quaternion</td>
            <tr></tr>
            <td width="250px"><a href="tensor.ctranspose.html"><tt>ctranspose</tt></a><span>   (tensor)</span></td>
            <td>conjugate of a tensor  Input T - @tensor  Output T - @tensor</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.ctranspose.html"><tt>ctranspose</tt></a><span>   (vector3d)</span></td>
            <td>transpose vector</td>
            <tr></tr>
            <td width="250px"><a href="cubeOrientation.html"><tt>cubeOrientation</tt></a></td>
            <td>returns the cube orientation</td>
            <tr></tr>
            <td width="250px"><a href="cunion.html"><tt>cunion</tt></a></td>
            <td>disjoint union</td>
            <tr></tr>
            <td width="250px"><a href="cut2unitI.html"><tt>cut2unitI</tt></a></td>
            <td></td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>D<a name="4"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="deg2dim.html"><tt>deg2dim</tt></a></td>
            <td>dimension of the harmonic space up to order l</td>
            <tr></tr>
            <td width="250px"><a href="degree.html"><tt>degree</tt></a></td>
            <td>x * degree =  x in standard arc measure</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.delete.html"><tt>delete</tt></a><span>   (S1Grid)</span></td>
            <td>delte points from S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.delete.html"><tt>delete</tt></a><span>   (S2Grid)</span></td>
            <td>elilinates points from grid</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.delete.html"><tt>delete</tt></a><span>   (SO3Grid)</span></td>
            <td>clear nodes by indece Input SOG    - @SO3Grid indece - int32</td>
            <tr></tr>
            <td width="250px"><a href="delete_option.html"><tt>delete_option</tt></a></td>
            <td>clear options in option list</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.diameter.html"><tt>diameter</tt></a><span>   (grain2d)</span></td>
            <td>diameter of a grain  longest distance between any two vertices of the grain boundary</td>
            <tr></tr>
            <td width="250px"><a href="dim2deg.html"><tt>dim2deg</tt></a></td>
            <td>dimension to harmonic degree of Wiegner D functions</td>
            <tr></tr>
            <td width="250px"><a href="tensor.directionalMagnitude.html"><tt>directionalMagnitude</tt></a><span>   (tensor)</span></td>
            <td>magnitude of a tensor in direction v</td>
            <tr></tr>
            <td width="250px"><a href="ODF.discreteSample.html"><tt>discreteSample</tt></a><span>   (ODF)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (ODFComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (femComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (fibreComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (uniformComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (unimodalComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.discreteSample.html"><tt>discreteSample</tt></a><span>   (quaternion)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.discreteSample.html"><tt>discreteSample</tt></a><span>   (vector3d)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="discretesample.html"><tt>discretesample</tt></a></td>
            <td>Samples from a discrete distribution</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.disjoint.html"><tt>disjoint</tt></a><span>   (symmetry)</span></td>
            <td>returns the disjoint of two symmetry groups</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.display.html"><tt>display</tt></a><span>   (EBSD)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.display.html"><tt>display</tt></a><span>   (grain2d)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.display.html"><tt>display</tt></a><span>   (grainBoundary)</span></td>
            <td>standard output  id  | mineralLeft | mineralRight ---------------------------------  #ids | mineralLeft | mineralRight
               ---------------------------------
            </td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.display.html"><tt>display</tt></a><span>   (BinghamComponent)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.display.html"><tt>display</tt></a><span>   (FourierComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="ODF.display.html"><tt>display</tt></a><span>   (ODF)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.display.html"><tt>display</tt></a><span>   (femComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.display.html"><tt>display</tt></a><span>   (fibreComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.display.html"><tt>display</tt></a><span>   (uniformComponent)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.display.html"><tt>display</tt></a><span>   (unimodalComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.display.html"><tt>display</tt></a><span>   (PoleFigure)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.display.html"><tt>display</tt></a><span>   (DelaunaySO3)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="Miller.display.html"><tt>display</tt></a><span>   (Miller)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.display.html"><tt>display</tt></a><span>   (S1Grid)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.display.html"><tt>display</tt></a><span>   (S2Grid)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.display.html"><tt>display</tt></a><span>   (SO3Grid)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.display.html"><tt>display</tt></a><span>   (crystalSymmetry)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="orientation.display.html"><tt>display</tt></a><span>   (orientation)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.display.html"><tt>display</tt></a><span>   (quaternion)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="rotation.display.html"><tt>display</tt></a><span>   (rotation)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="tensor.display.html"><tt>display</tt></a><span>   (tensor)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.display.html"><tt>display</tt></a><span>   (vector3d)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="displayClass.html"><tt>displayClass</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.dist.html"><tt>dist</tt></a><span>   (S1Grid)</span></td>
            <td>distance to all points of S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.dist_outer.html"><tt>dist_outer</tt></a><span>   (S1Grid)</span></td>
            <td>distance to all points of S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="doclink.html"><tt>doclink</tt></a></td>
            <td>on Octave skip this</td>
            <tr></tr>
            <td width="250px"><a href="docmethods.html"><tt>docmethods</tt></a></td>
            <td>for octave skip this</td>
            <tr></tr>
            <td width="250px"><a href="docopt.html"><tt>docopt</tt></a></td>
            <td>DOCOPT Web browser for UNIX platforms. DOCOPT is an M-file that you or your system manager can edit to specify the Web browser
               to use with MATLAB. It is used for the WEB function with the -BROWSER option. It is also used for links to external Web sites
               from the the Help browser and from Web menu items. DOCOPT applies only to non-Macintosh UNIX platforms.
            </td>
            <tr></tr>
            <td width="250px"><a href="Miller.dot.html"><tt>dot</tt></a><span>   (Miller)</span></td>
            <td>inner product between two Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="orientation.dot.html"><tt>dot</tt></a><span>   (orientation)</span></td>
            <td>compute minimum dot(o1,o2) modulo symmetry</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot.html"><tt>dot</tt></a><span>   (quaternion)</span></td>
            <td>inner product of quaternions g1 and g2</td>
            <tr></tr>
            <td width="250px"><a href="rotation.dot.html"><tt>dot</tt></a><span>   (rotation)</span></td>
            <td>compute rot1 . rot2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dot.html"><tt>dot</tt></a><span>   (vector3d)</span></td>
            <td>pointwise inner product</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot_angle.html"><tt>dot_angle</tt></a><span>   (quaternion)</span></td>
            <td>compute minimum q1 . q2 modulo rotation about zaxis and angle omega</td>
            <tr></tr>
            <td width="250px"><a href="Miller.dot_outer.html"><tt>dot_outer</tt></a><span>   (Miller)</span></td>
            <td>inner product between two Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.dot_outer.html"><tt>dot_outer</tt></a><span>   (SO3Grid)</span></td>
            <td>return outer inner product of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="orientation.dot_outer.html"><tt>dot_outer</tt></a><span>   (orientation)</span></td>
            <td>dot_outer</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot_outer.html"><tt>dot_outer</tt></a><span>   (quaternion)</span></td>
            <td>outer inner product between two quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.dot_outer.html"><tt>dot_outer</tt></a><span>   (rotation)</span></td>
            <td>dot_outer</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dot_outer.html"><tt>dot_outer</tt></a><span>   (vector3d)</span></td>
            <td>outer dot product</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.double.html"><tt>double</tt></a><span>   (S1Grid)</span></td>
            <td>convert to double</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.double.html"><tt>double</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to double</td>
            <tr></tr>
            <td width="250px"><a href="tensor.double.html"><tt>double</tt></a><span>   (tensor)</span></td>
            <td>convert tensor values to matrix</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.double.html"><tt>double</tt></a><span>   (vector3d)</span></td>
            <td>converts vector3d to double</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.drawNow.html"><tt>drawNow</tt></a><span>   (mtexFigure)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="Miller.dspacing.html"><tt>dspacing</tt></a><span>   (Miller)</span></td>
            <td>space between crystal planes</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>E<a name="5"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="efopen.html"><tt>efopen</tt></a></td>
            <td>file open with error message</td>
            <tr></tr>
            <td width="250px"><a href="tensor.eig.html"><tt>eig</tt></a><span>   (tensor)</span></td>
            <td>compute the eigenvalues and eigenvectors of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.EinsteinSum.html"><tt>EinsteinSum</tt></a><span>   (tensor)</span></td>
            <td>tensor multiplication according to Einstein summation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.end.html"><tt>end</tt></a><span>   (quaternion)</span></td>
            <td>overloads end function</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.end.html"><tt>end</tt></a><span>   (vector3d)</span></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="ensurecell.html"><tt>ensurecell</tt></a></td>
            <td>ensures that v is a cell with size s</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.ensureCS.html"><tt>ensureCS</tt></a><span>   (symmetry)</span></td>
            <td>ensures that an obj has the right crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="ensureNonNeg.html"><tt>ensureNonNeg</tt></a></td>
            <td>remove small negative values</td>
            <tr></tr>
            <td width="250px"><a href="ODF.entropy.html"><tt>entropy</tt></a><span>   (ODF)</span></td>
            <td>caclulate entropy of ODF</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.eq.html"><tt>eq</tt></a><span>   (grain2d)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.eq.html"><tt>eq</tt></a><span>   (S1Grid)</span></td>
            <td>implements G1 == G2</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.eq.html"><tt>eq</tt></a><span>   (crystalSymmetry)</span></td>
            <td>check S1 == S2</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.eq.html"><tt>eq</tt></a><span>   (orientationRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.eq.html"><tt>eq</tt></a><span>   (quaternion)</span></td>
            <td>? q1 == q2</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.eq.html"><tt>eq</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="symmetry.eq.html"><tt>eq</tt></a><span>   (symmetry)</span></td>
            <td>check S1 == S2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.eq.html"><tt>eq</tt></a><span>   (tensor)</span></td>
            <td>checks whether two tensors are equal</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.eq.html"><tt>eq</tt></a><span>   (vector3d)</span></td>
            <td>? v1 == v2</td>
            <tr></tr>
            <td width="250px"><a href="equal.html"><tt>equal</tt></a></td>
            <td>check all elements of A to be equal</td>
            <tr></tr>
            <td width="250px"><a href="equispacedS2Grid.html"><tt>equispacedS2Grid</tt></a></td>
            <td>defines an equispaced spherical grid</td>
            <tr></tr>
            <td width="250px"><a href="equispacedSO3Grid.html"><tt>equispacedSO3Grid</tt></a></td>
            <td>defines a equispaced grid in the orientation space</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.equivalentPerimeter.html"><tt>equivalentPerimeter</tt></a><span>   (grain2d)</span></td>
            <td>returns the equivalent perimeter of grain-polygon  defined as  $$ p = 2 \pi ER $$,  where $ER$ is the [[Grain2d.equivalentRadius.html,equivalent
               radius]] of a grain  Input grains - @grain2d  Output p   - perimeter  See also grain2d/deltaarea grain2d/paris grain2d/equivalentRadius
            </td>
            <tr></tr>
            <td width="250px"><a href="grain2d.equivalentRadius.html"><tt>equivalentRadius</tt></a><span>   (grain2d)</span></td>
            <td>returns the equivalent radius of grain-polygon  defined as   $$ r = \sqrt{\frac{A}{\pi}} $$,  where $A$ is the [[Grain2d.area.html,area]]
               of a grain  Input grains - @grain2d  Output r  - radius  See also grain2d/deltaarea grain2d/equivalentPerimeter grain2d/paris
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.Euler.html"><tt>Euler</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to euler angle</td>
            <tr></tr>
            <td width="250px"><a href="euler2quat.html"><tt>euler2quat</tt></a></td>
            <td>converts euler angle to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="EulerAngleConvention.html"><tt>EulerAngleConvention</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="EulerCycles.html"><tt>EulerCycles</tt></a></td>
            <td>retrieve Euler cycles from an not oriented edge list</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.eval.html"><tt>eval</tt></a><span>   (BinghamComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.eval.html"><tt>eval</tt></a><span>   (FourierComponent)</span></td>
            <td>evaluate odf using NSOFT</td>
            <tr></tr>
            <td width="250px"><a href="ODF.eval.html"><tt>eval</tt></a><span>   (ODF)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.eval.html"><tt>eval</tt></a><span>   (femComponent)</span></td>
            <td>evaluate an odf at orientation ori</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.eval.html"><tt>eval</tt></a><span>   (fibreComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.eval.html"><tt>eval</tt></a><span>   (uniformComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.eval.html"><tt>eval</tt></a><span>   (unimodalComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="evalkappa.html"><tt>evalkappa</tt></a></td>
            <td>eigenvalues of orientation tensor to bingham distribution parameters  Options approximated - approximated solution of kappas
               precision    - precision of solvus iteration    - number of newton interations  See also orientation/mean EBSD/mean BinghamODF
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.expm.html"><tt>expm</tt></a><span>   (tensor)</span></td>
            <td>matrix exponential of a tensor  Input T - @tensor  Output T - @tensor</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.export.html"><tt>export</tt></a><span>   (EBSD)</span></td>
            <td>export EBSD data to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export.html"><tt>export</tt></a><span>   (ODF)</span></td>
            <td>export an ODF to an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.export.html"><tt>export</tt></a><span>   (PoleFigure)</span></td>
            <td>export pole figure in an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.export.html"><tt>export</tt></a><span>   (quaternion)</span></td>
            <td>export quaternions to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.export.html"><tt>export</tt></a><span>   (vector3d)</span></td>
            <td>export quaternions to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_generic.html"><tt>export_generic</tt></a><span>   (ODF)</span></td>
            <td>export an ODF to an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.export_h5.html"><tt>export_h5</tt></a><span>   (EBSD)</span></td>
            <td>export EBSD data to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_mtex.html"><tt>export_mtex</tt></a><span>   (ODF)</span></td>
            <td>export an ODF into the MTEX format</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_VPSC.html"><tt>export_VPSC</tt></a><span>   (ODF)</span></td>
            <td>export an ODF to the VPSC format</td>
            <tr></tr>
            <td width="250px"><a href="orientation.export_VPSC.html"><tt>export_VPSC</tt></a><span>   (orientation)</span></td>
            <td>export individual orientations to the VPSC format</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.extend.html"><tt>extend</tt></a><span>   (EBSD)</span></td>
            <td>returns the boundings of spatial EBSD data  Output ext - extend as [xmin xmax ymin ymax zmin zmax]</td>
            <tr></tr>
            <td width="250px"><a href="extract_argoption.html"><tt>extract_argoption</tt></a></td>
            <td>extract options from option list</td>
            <tr></tr>
            <td width="250px"><a href="extract_kernel.html"><tt>extract_kernel</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="extract_option.html"><tt>extract_option</tt></a></td>
            <td>extract options from option list</td>
            <tr></tr>
            <td width="250px"><a href="extract_SO3grid.html"><tt>extract_SO3grid</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="extractOptions.html"><tt>extractOptions</tt></a></td>
            <td>extract options from option list</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>F<a name="6"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="symmetry.factor.html"><tt>factor</tt></a><span>   (symmetry)</span></td>
            <td>factorizes s1 and s2 into l, d, r such that s1 = l * d and s2 = d * r</td>
            <tr></tr>
            <td width="250px"><a href="fclencurt.html"><tt>fclencurt</tt></a></td>
            <td>Fast Clenshaw Curtis Quadrature</td>
            <tr></tr>
            <td width="250px"><a href="femODF.html"><tt>femODF</tt></a></td>
            <td>defines an ODF by finite elements</td>
            <tr></tr>
            <td width="250px"><a href="fft_rho.html"><tt>fft_rho</tt></a></td>
            <td>project rho to interval [-1,1)</td>
            <tr></tr>
            <td width="250px"><a href="fft_theta.html"><tt>fft_theta</tt></a></td>
            <td>project theta to interval [0,0.5]</td>
            <tr></tr>
            <td width="250px"><a href="fibre2quat.html"><tt>fibre2quat</tt></a></td>
            <td>arbitrary quaternion q with q * h = r</td>
            <tr></tr>
            <td width="250px"><a href="fibreODF.html"><tt>fibreODF</tt></a></td>
            <td>defines an fibre symmetric ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.fibreVolume.html"><tt>fibreVolume</tt></a><span>   (ODF)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.fibreVolume.html"><tt>fibreVolume</tt></a><span>   (orientation)</span></td>
            <td>ratio of orientations close to a certain fibre</td>
            <tr></tr>
            <td width="250px"><a href="fibreVonMisesFisherKernel.html"><tt>fibreVonMisesFisherKernel</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="file2cell.html"><tt>file2cell</tt></a></td>
            <td>reads a file rowise into a cellstr</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fill.html"><tt>fill</tt></a><span>   (EBSD)</span></td>
            <td>extrapolate spatial EBSD data by nearest neighbour for tetragonal lattice  Input ebsd - @EBSD  Example ebsd_filled =
               fill(ebsd)
            </td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.find.html"><tt>find</tt></a><span>   (S1Grid)</span></td>
            <td>find close points</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.find.html"><tt>find</tt></a><span>   (S2Grid)</span></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.find.html"><tt>find</tt></a><span>   (SO3Grid)</span></td>
            <td>return indece and distance of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.find.html"><tt>find</tt></a><span>   (quaternion)</span></td>
            <td>return indece and distance of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.find.html"><tt>find</tt></a><span>   (vector3d)</span></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="find_option.html"><tt>find_option</tt></a></td>
            <td>find postions of the options in option_list</td>
            <tr></tr>
            <td width="250px"><a href="find_type.html"><tt>find_type</tt></a></td>
            <td>parse arguments list for a specific type an returns the first occurance</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.findByLocation.html"><tt>findByLocation</tt></a><span>   (EBSD)</span></td>
            <td>select EBSD data by spatial coordinates  Input ebsd - @EBSD xy - list of [x(:) y(:)] coordinates, respectively [x(:) y(:)
               z(:)]  Output ebsd - @EBSD subset  Example  plotx2east plot(ebsd) p = ginput(1) g = findByLocation(ebsd,p)  See
               also EBSD/findByLocation GrainSet/findByOrientation
            </td>
            <tr></tr>
            <td width="250px"><a href="grain2d.findByLocation.html"><tt>findByLocation</tt></a><span>   (grain2d)</span></td>
            <td>select a grain by spatial coordinates  Input grains - @grain2d xy     - list of [x(:) y(:)] coordinates, respectively
               [x(:) y(:) z(:)]  Output grains - list of grainIds  Example plotx2east plot(grains) p = ginput(1) id = findByLocation(grains,p);
               hold on, plot(grains(id).boundary,'linecolor','r','lineWidth',2), hold off  See also EBSD/findByLocation GrainSet/findByOrientation
            </td>
            <tr></tr>
            <td width="250px"><a href="EBSD.findByOrientation.html"><tt>findByOrientation</tt></a><span>   (EBSD)</span></td>
            <td>select grains by orientation  Input ebsd    - @EBSD q0      - @quaternion | @rotation | @orientation  epsilon - searching
               radius  Output ebsd - @EBSD  See also EBSD/findByLocation GrainSet/findByOrientation
            </td>
            <tr></tr>
            <td width="250px"><a href="grain2d.findByOrientation.html"><tt>findByOrientation</tt></a><span>   (grain2d)</span></td>
            <td>select grains by orientation  Input grains - @GrainSet q0 - @quaternion | @rotation | @orientation  epsilon - searching
               radius  Output grains - @GrainSet  Example  g = findByOrientation(grains,idquaternion,10*degree);  See also EBSD/findByLocation
               GrainSet/findByOrientation
            </td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.findOutlier.html"><tt>findOutlier</tt></a><span>   (PoleFigure)</span></td>
            <td>find outliers in pole figures</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.findTetra.html"><tt>findTetra</tt></a><span>   (DelaunaySO3)</span></td>
            <td>find tetrahegon</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fliplr.html"><tt>fliplr</tt></a><span>   (EBSD)</span></td>
            <td>flip spatial ebsd-data from left to right  Input ebsd - @EBSD  Output flipped ebsd - @EBSD</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.flipud.html"><tt>flipud</tt></a><span>   (EBSD)</span></td>
            <td>flip spatial ebsd-data from upside down  Input ebsd - @EBSD  Output flipped ebsd - @EBSD</td>
            <tr></tr>
            <td width="250px"><a href="FMC_Coarsen.html"><tt>FMC_Coarsen</tt></a></td>
            <td>Performs one coarsening step.</td>
            <tr></tr>
            <td width="250px"><a href="FMC_interpret.html"><tt>FMC_interpret</tt></a></td>
            <td>Interpretation of FMC data and grain assignment</td>
            <tr></tr>
            <td width="250px"><a href="FMC_MTEX.html"><tt>FMC_MTEX</tt></a></td>
            <td>setup Wnext</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.Fourier.html"><tt>Fourier</tt></a><span>   (FourierComponent)</span></td>
            <td>get Fourier coefficients of and ODF</td>
            <tr></tr>
            <td width="250px"><a href="tensor.Fourier.html"><tt>Fourier</tt></a><span>   (tensor)</span></td>
            <td>compute the Fourier coefficients of the tensor  Description  Input T - @tensor  Options order -   Output F - Fourier
               coefficients as an 2*rank+1 x 2*rank + 1 matrix
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.FourierODF.html"><tt>FourierODF</tt></a><span>   (ODF)</span></td>
            <td>compute FourierODF from another ODF</td>
            <tr></tr>
            <td width="250px"><a href="FourierODF.html"><tt>FourierODF</tt></a></td>
            <td>defines an ODF by its Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalRegion.html"><tt>fundamentalRegion</tt></a><span>   (symmetry)</span></td>
            <td>get the fundamental sector for a symmetry in the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalSector.html"><tt>fundamentalSector</tt></a><span>   (symmetry)</span></td>
            <td>get the fundamental sector for a symmetry in the inverse pole figure</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>G<a name="7"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="GaussWeierstrassKernel.html"><tt>GaussWeierstrassKernel</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="gcm.html"><tt>gcm</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="generic_wizard.html"><tt>generic_wizard</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="get_flag.html"><tt>get_flag</tt></a></td>
            <td>extract flag from option list</td>
            <tr></tr>
            <td width="250px"><a href="get_obj_fields.html"><tt>get_obj_fields</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="get_option.html"><tt>get_option</tt></a></td>
            <td>extract option from option list</td>
            <tr></tr>
            <td width="250px"><a href="getCamera.html"><tt>getCamera</tt></a></td>
            <td>get xAxis and zAxis position from axis</td>
            <tr></tr>
            <td width="250px"><a href="getClass.html"><tt>getClass</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.getdata.html"><tt>getdata</tt></a><span>   (S2Grid)</span></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.getDataCursorPos.html"><tt>getDataCursorPos</tt></a><span>   (mtexFigure)</span></td>
            <td>get the position and value of the data cursor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.getFundamentalRegion.html"><tt>getFundamentalRegion</tt></a><span>   (orientation)</span></td>
            <td>projects orientations to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.getFundamentalRegion.html"><tt>getFundamentalRegion</tt></a><span>   (symmetry)</span></td>
            <td>get the fundamental region in Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.getFundamentalRegionRodrigues.html"><tt>getFundamentalRegionRodrigues</tt></a><span>   (symmetry)</span></td>
            <td>get the fundamental region for a crystal and specimen symmetry</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.getFundamentalRegionRodriguez.html"><tt>getFundamentalRegionRodriguez</tt></a><span>   (symmetry)</span></td>
            <td>get the fundamental region for a crystal and specimen symmetry</td>
            <tr></tr>
            <td width="250px"><a href="getHoldState.html"><tt>getHoldState</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="getmem.html"><tt>getmem</tt></a></td>
            <td>return total system memory in kb</td>
            <tr></tr>
            <td width="250px"><a href="rotation.getMinAxes.html"><tt>getMinAxes</tt></a><span>   (rotation)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="getMTEXpref.html"><tt>getMTEXpref</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="getSubDirs.html"><tt>getSubDirs</tt></a></td>
            <td>getSubDirs - gets recursively all subdirectories of a given directory.</td>
            <tr></tr>
            <td width="250px"><a href="gossOrientation.html"><tt>gossOrientation</tt></a></td>
            <td>returns the cube orientation</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.GridLength.html"><tt>GridLength</tt></a><span>   (S1Grid)</span></td>
            <td>return number of points</td>
            <tr></tr>
            <td width="250px"><a href="guessfibre.html"><tt>guessfibre</tt></a></td>
            <td>try to find the fibre of to given rotations by finding the eigenvector of g_1*h = g_2*h -&gt; (g_2^-1)*g_1* h = h -&gt; R*h = (lambda)*h
                Input g1 - @rotation, @ODF g2 - @rotation  Output h -  r -  v - (in case of odf) fibre volumn  Options resolution
               - discretisation parameter  See also fibreODF rotation
            </td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>H<a name="8"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="grain2d.hasHole.html"><tt>hasHole</tt></a><span>   (grain2d)</span></td>
            <td>test if a grain has a hole or not  Input grains - @Grain2d  Output h  - logical array, |true| if a grain has hole</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.hist.html"><tt>hist</tt></a><span>   (grain2d)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="ODF.hist.html"><tt>hist</tt></a><span>   (ODF)</span></td>
            <td>calcualtes a histogram of ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.horzcat.html"><tt>horzcat</tt></a><span>   (orientationRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.horzcat.html"><tt>horzcat</tt></a><span>   (quaternion)</span></td>
            <td>implements [q1,q2,q3..]</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.horzcat.html"><tt>horzcat</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="tensor.horzcat.html"><tt>horzcat</tt></a><span>   (tensor)</span></td>
            <td>overloads [T1,T2,T3..]</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.horzcat.html"><tt>horzcat</tt></a><span>   (vector3d)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="hotColorMap.html"><tt>hotColorMap</tt></a></td>
            <td>HOT    Black-red-yellow-white color map HOT(M) returns an M-by-3 matrix containing a "hot" colormap. HOT, by itself, is the
               same length as the current figure's colormap. If no figure exists, MATLAB creates one.
            </td>
            <tr></tr>
            <td width="250px"><a href="hr2quat.html"><tt>hr2quat</tt></a></td>
            <td>arbitrary quaternion q with q * h = r</td>
            <tr></tr>
            <td width="250px"><a href="hsl2hsv.html"><tt>hsl2hsv</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="hsvColorMap.html"><tt>hsvColorMap</tt></a></td>
            <td>HSV    Hue-saturation-value color map HSV(M) returns an M-by-3 matrix containing an HSV colormap. HSV, by itself, is the same
               length as the current figure's colormap. If no figure exists, MATLAB creates one.
            </td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>I<a name="9"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="idquaternion.html"><tt>idquaternion</tt></a></td>
            <td>the identical rotation - quaternion(1,0,0,0)</td>
            <tr></tr>
            <td width="250px"><a href="idRotation.html"><tt>idRotation</tt></a></td>
            <td>the identical rotation</td>
            <tr></tr>
            <td width="250px"><a href="import_wizard.html"><tt>import_wizard</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="ind2char.html"><tt>ind2char</tt></a></td>
            <td>calculates coordinate from one index i - index s - size of matrix</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.inpolygon.html"><tt>inpolygon</tt></a><span>   (EBSD)</span></td>
            <td>checks which ebsd data are within given polygon  Syntax ind = inpolygon(ebsd,[xmin,ymin,dx,dy]) % select indices by rectangle
               ind = inpolygon(ebsd,[x1 y1; x2 y2; x3 y3; x4 y4]) % select indices by poylgon ebsd = ebsd(ind) % select EBSD data by indices
                Input ebsd    - @EBSD xmin, xmax - lower left corner of a rectangle dx, dy - extend of a rectangle x, y  - vertices
               of a polygon  Ouput ind - logical  See also inpolygon
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.interp.html"><tt>interp</tt></a><span>   (vector3d)</span></td>
            <td>dirty spherical interpolation - including some smoothing</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.intersect.html"><tt>intersect</tt></a><span>   (grainBoundary)</span></td>
            <td>length of a boundary segment  Syntax [x,y] = intersect(gB,xy1,xy2) [x,y,segLength] = intersect(gB,xy1,xy2)  Input gb
               - @grainBoundary xy1, xy2 coordinates of the endpoints of the line  Output x,y - list of intersection points  Example
               mtexdata csl grains = calcGrains(ebsd) plot(grains.boundary) % define some line xy1 = [0,10];  % staring point xy2 =
               [31,41]; % end point line([xy1(1);xy2(1)],[xy1(2);xy2(2)],'linewidth',1.5,'color','g') [x,y] = grains.boundary.intersect(xy1,xy2);
               hold on scatter(x,y,'red') hold off % find the number of intersection points   sum(~isnan(x))
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.inv.html"><tt>inv</tt></a><span>   (orientation)</span></td>
            <td>inverse of an orientation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.inv.html"><tt>inv</tt></a><span>   (quaternion)</span></td>
            <td>quaternion of the inverse roation</td>
            <tr></tr>
            <td width="250px"><a href="tensor.inv.html"><tt>inv</tt></a><span>   (tensor)</span></td>
            <td>inverse of a tensor  Input T - @tensor  Output T - @tensor</td>
            <tr></tr>
            <td width="250px"><a href="inversion.html"><tt>inversion</tt></a></td>
            <td>the inversion - reflection at the origin</td>
            <tr></tr>
            <td width="250px"><a href="isappr.html"><tt>isappr</tt></a></td>
            <td>check double == double</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.isempty.html"><tt>isempty</tt></a><span>   (PoleFigure)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.isempty.html"><tt>isempty</tt></a><span>   (quaternion)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.isempty.html"><tt>isempty</tt></a><span>   (vector3d)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="isempty_cell.html"><tt>isempty_cell</tt></a></td>
            <td>isempty for cells</td>
            <tr></tr>
            <td width="250px"><a href="iseven.html"><tt>iseven</tt></a></td>
            <td>check double mod 2 == 0</td>
            <tr></tr>
            <td width="250px"><a href="ODF.isFourier.html"><tt>isFourier</tt></a><span>   (ODF)</span></td>
            <td>check whether odf is given by Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="rotation.isImproper.html"><tt>isImproper</tt></a><span>   (rotation)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.isLower.html"><tt>isLower</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="orientation.isMisorientation.html"><tt>isMisorientation</tt></a><span>   (orientation)</span></td>
            <td>check whether o is a misorientation</td>
            <tr></tr>
            <td width="250px"><a href="isnull.html"><tt>isnull</tt></a></td>
            <td>ckeck double == 0</td>
            <tr></tr>
            <td width="250px"><a href="isOctave.html"><tt>isOctave</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.isOutlier.html"><tt>isOutlier</tt></a><span>   (PoleFigure)</span></td>
            <td>find outliers in pole figures</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.isPerp.html"><tt>isPerp</tt></a><span>   (vector3d)</span></td>
            <td>check whether v1 and v2 are orthogonal</td>
            <tr></tr>
            <td width="250px"><a href="ispos.html"><tt>ispos</tt></a></td>
            <td>check double &gt; 0</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.isTwinning.html"><tt>isTwinning</tt></a><span>   (grainBoundary)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.isUpper.html"><tt>isUpper</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>K<a name="10"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="kernel.K_symmetrised.html"><tt>K_symmetrised</tt></a><span>   (kernel)</span></td>
            <td>evaluate kernel modulo symmetries</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.KAM.html"><tt>KAM</tt></a><span>   (EBSD)</span></td>
            <td>intergranular average misorientation angle per orientation  Syntax  % ignore misorientation angles &gt; threshold kam =
               KAM(ebsd,'threshold',10*degree); plot(ebsd,ebsd.KAM./degree)  % ignore grain boundary misorientations [ebsd, ebsd.grainId]
               = calcGrains(ebsd) kam = KAM(ebsd);  plot(ebsd,ebsd.KAM./degree)  % consider also second order neigbors kam = KAM(ebsd,'order',2);
                Input ebsd - @ebsd  Options threshold - ignore misorientation angles larger then threshold order     - consider neighbors
               of order n  See alo grain2d.GOS
            </td>
            <tr></tr>
            <td width="250px"><a href="kde.html"><tt>kde</tt></a></td>
            <td>Reliable and extremely fast kernel density estimator for one-dimensional data; Gaussian kernel is assumed and the bandwidth
               is chosen automatically; Unlike many other implementations, this one is immune to problems caused by multimodal densities
               with widely separated modes (see example). The estimation does not deteriorate for multimodal densities, because we never
               assume a parametric model for the data. INPUTS: data    - a vector of data from which the density estimate is constructed;
               n  - the number of mesh points used in the uniform discretization of the interval [MIN, MAX]; n has to be a power of two;
               if n is not a power of two, then n is rounded up to the next power of two, i.e., n is set to n=2^ceil(log2(n)); the default
               value of n is n=2^12; MIN, MAX  - defines the interval [MIN,MAX] on which the density estimate is constructed; the default
               values of MIN and MAX are: MIN=min(data)-Range/10 and MAX=max(data)+Range/10, where Range=max(data)-min(data); OUTPUTS:
               bandwidth - the optimal bandwidth (Gaussian kernel assumed); density - column vector of length 'n' with the values of the
               density estimate at the grid points; xmesh   - the grid over which the density estimate is computed; - If no output is
               requested, then the code automatically plots a graph of the density estimate. cdf  - column vector of length 'n' with the
               values of the cdf Reference:  Kernel density estimation via diffusion Z. I. Botev, J. F. Grotowski, and D. P. Kroese (2010)
               Annals of Statistics, Volume 38, Number 5, pages 2916-2957.
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.kernelDensityEstimation.html"><tt>kernelDensityEstimation</tt></a><span>   (vector3d)</span></td>
            <td>calculates a density function out of (weighted) unit vectors  Input v   - @vector3d out - @vector3d  Options halfwidth
               - halfwidth of a kernel kernel    - specifies a kernel weights   - vector of weights, with same length as v
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.KLCV.html"><tt>KLCV</tt></a><span>   (orientation)</span></td>
            <td>Kullback Leibler cross validation for optimal kernel estimation</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>L<a name="11"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="LaboTeXColorMap.html"><tt>LaboTeXColorMap</tt></a></td>
            <td>return LaboTeX colormap</td>
            <tr></tr>
            <td width="250px"><a href="LaplaceKernel.html"><tt>LaplaceKernel</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="symmetry.Laue.html"><tt>Laue</tt></a><span>   (symmetry)</span></td>
            <td>return the corresponding Laue group</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.LaueName.html"><tt>LaueName</tt></a><span>   (symmetry)</span></td>
            <td>get Laue name</td>
            <tr></tr>
            <td width="250px"><a href="orientation.ldivide.html"><tt>ldivide</tt></a><span>   (orientation)</span></td>
            <td>o .\ v   Syntax h = o .\ r  Input o - @orientation r - @vector3d  Output h - @Miller indice  See also</td>
            <tr></tr>
            <td width="250px"><a href="legendre0.html"><tt>legendre0</tt></a></td>
            <td>Legendrepolynome bis zur Odnung N und gibt sie als Matrix zur&#65533;ck erste Dimension -&gt; Ordnung zweite Dimension -&gt; x</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.length.html"><tt>length</tt></a><span>   (quaternion)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.length.html"><tt>length</tt></a><span>   (symmetry)</span></td>
            <td>number of symmetry elements</td>
            <tr></tr>
            <td width="250px"><a href="tensor.length.html"><tt>length</tt></a><span>   (tensor)</span></td>
            <td>returns the number of tensors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.length.html"><tt>length</tt></a><span>   (vector3d)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.line.html"><tt>line</tt></a><span>   (vector3d)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="tensor.linearCompressibility.html"><tt>linearCompressibility</tt></a><span>   (tensor)</span></td>
            <td>computes the linear compressibility of an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="load_generic.html"><tt>load_generic</tt></a></td>
            <td>load file using import data and txt2mat</td>
            <tr></tr>
            <td width="250px"><a href="loadCIF.html"><tt>loadCIF</tt></a></td>
            <td>import crystal symmetry from cif file</td>
            <tr></tr>
            <td width="250px"><a href="loadData.html"><tt>loadData</tt></a></td>
            <td>import PoleFigure, EBSD, and ODF data</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD.html"><tt>loadEBSD</tt></a></td>
            <td>import ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ACOM.html"><tt>loadEBSD_ACOM</tt></a></td>
            <td>read ACOM files (converted from *.res ASTAR)  Syntax ebsd = loadEBSD_ACOM(fname) ebsd = loadEBSD_ACOM(fname,'convertSpatial2EulerReferenceFrame')
               ebsd = loadEBSD_ACOM(fname,'convertEuler2SpatialReferenceFrame')  Input fname - file name  Flags convertSpatial2EulerReferenceFrame
               - change x and y values such that spatial and Euler reference frame coincide, i.e., rotate them by 180 degree convertEuler2SpatialReferenceFrame
               - change the Euler angles such that spatial and Euler reference frame coincide, i.e., rotate them by 180 degree
            </td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ang.html"><tt>loadEBSD_ang</tt></a></td>
            <td>read TSL *.ang file</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_brukertxt.html"><tt>loadEBSD_brukertxt</tt></a></td>
            <td>read Bruker *.txt file</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_crc.html"><tt>loadEBSD_crc</tt></a></td>
            <td>interface for Oxford Chanel 5 crc and cpr EBSD data files</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_csv.html"><tt>loadEBSD_csv</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ctf.html"><tt>loadEBSD_ctf</tt></a></td>
            <td>read HKL *.ctf file</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_dream3d.html"><tt>loadEBSD_dream3d</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ebsdimage.html"><tt>loadEBSD_ebsdimage</tt></a></td>
            <td>Check extension</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_generic.html"><tt>loadEBSD_generic</tt></a></td>
            <td>load ebsd data from generic text files</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_h5.html"><tt>loadEBSD_h5</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_hdf5.html"><tt>loadEBSD_hdf5</tt></a></td>
            <td>Read rotations</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_osc.html"><tt>loadEBSD_osc</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_Oxfordcsv.html"><tt>loadEBSD_Oxfordcsv</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_sor.html"><tt>loadEBSD_sor</tt></a></td>
            <td>load LaboTex *.sor file</td>
            <tr></tr>
            <td width="250px"><a href="loadGrainSet_hdf5.html"><tt>loadGrainSet_hdf5</tt></a></td>
            <td>Read EBSD</td>
            <tr></tr>
            <td width="250px"><a href="loadHelper.html"><tt>loadHelper</tt></a></td>
            <td>helps to load data-matrix with ColumnNames restricts also data according to conventions (e.g. &gt;4pi)  Input d -  (n x m)
               matrix ColumnNames - (1 x m) cell of names Columns - (1 x m) cell of ColumnNames indizes  Options KeepNaN Radians passive
               rotation ... Output loader  - structure with some funs
            </td>
            <tr></tr>
            <td width="250px"><a href="loadODF.html"><tt>loadODF</tt></a></td>
            <td>import ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="loadODF_generic.html"><tt>loadODF_generic</tt></a></td>
            <td>load pole figure data from (alpha,beta,gamma) files</td>
            <tr></tr>
            <td width="250px"><a href="loadODF_VPSC.html"><tt>loadODF_VPSC</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadOrientation.html"><tt>loadOrientation</tt></a></td>
            <td>import orientation data from data files</td>
            <tr></tr>
            <td width="250px"><a href="loadOrientation_DRex.html"><tt>loadOrientation_DRex</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadOrientation_generic.html"><tt>loadOrientation_generic</tt></a></td>
            <td>load Orientation data from generic text files</td>
            <tr></tr>
            <td width="250px"><a href="loadPHL.html"><tt>loadPHL</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure.html"><tt>loadPoleFigure</tt></a></td>
            <td>import pole figure data</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_aachen.html"><tt>loadPoleFigure_aachen</tt></a></td>
            <td>import data fom aachen ptx file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_aachen_exp.html"><tt>loadPoleFigure_aachen_exp</tt></a></td>
            <td>import data fom aachen_exp file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_ana.html"><tt>loadPoleFigure_ana</tt></a></td>
            <td>import data fom ana file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_beartex.html"><tt>loadPoleFigure_beartex</tt></a></td>
            <td>import data fom BeaTex file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_dubna.html"><tt>loadPoleFigure_dubna</tt></a></td>
            <td>load dubna cnv file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_geesthacht.html"><tt>loadPoleFigure_geesthacht</tt></a></td>
            <td>load ptx file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_generic.html"><tt>loadPoleFigure_generic</tt></a></td>
            <td>load pole figure data from (theta,rho,intensity) files</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_gpol.html"><tt>loadPoleFigure_gpol</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_ibm.html"><tt>loadPoleFigure_ibm</tt></a></td>
            <td>import data fom ibm file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_juelich.html"><tt>loadPoleFigure_juelich</tt></a></td>
            <td>load juelich data format</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_labotex.html"><tt>loadPoleFigure_labotex</tt></a></td>
            <td>load labotex pole figure data</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_nja.html"><tt>loadPoleFigure_nja</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_out1.html"><tt>loadPoleFigure_out1</tt></a></td>
            <td>import polfigure-data form Graz</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_philips.html"><tt>loadPoleFigure_philips</tt></a></td>
            <td>load philips *.txt file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_plf.html"><tt>loadPoleFigure_plf</tt></a></td>
            <td>load plf file  Syntax pf = loadPoleFigure_plf(fname,&lt;options&gt;)  Input fname - file name  Output pf    - @PoleFigure</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_popla.html"><tt>loadPoleFigure_popla</tt></a></td>
            <td>import data fom Popla file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_pwd.html"><tt>loadPoleFigure_pwd</tt></a></td>
            <td>load D5000 powder data file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rigaku.html"><tt>loadPoleFigure_rigaku</tt></a></td>
            <td>import data fom Rigaku SamrtLab txt file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rigaku_dat.html"><tt>loadPoleFigure_rigaku_dat</tt></a></td>
            <td>load *.dat files of rigaku devices</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rigaku_txt.html"><tt>loadPoleFigure_rigaku_txt</tt></a></td>
            <td>import data fom ana file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rw1.html"><tt>loadPoleFigure_rw1</tt></a></td>
            <td>import data from Philip's Xpert binary file format rw1  Syntax pf = loadPoleFigure_rw1(fname)  Input fname  - filename
                Output pf - vector of @PoleFigure  See also ImportPoleFigureData loadPoleFigure
            </td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_scintag.html"><tt>loadPoleFigure_scintag</tt></a></td>
            <td>import data fom scintag ascii file  Syntax pf = loadPoleFigure_scintag(fname,&lt;options&gt;)  Input fname    - filename
                Output pf - vector of @PoleFigure  See also ImportPoleFigureData loadPoleFigure
            </td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_siemens.html"><tt>loadPoleFigure_siemens</tt></a></td>
            <td>load D5000 data file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_slc.html"><tt>loadPoleFigure_slc</tt></a></td>
            <td>load *.txt file with regular grid</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_uxd.html"><tt>loadPoleFigure_uxd</tt></a></td>
            <td>import data fom ana file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_xrd.html"><tt>loadPoleFigure_xrd</tt></a></td>
            <td>import data fom aachen xrd file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_xrdml.html"><tt>loadPoleFigure_xrdml</tt></a></td>
            <td>load xrdMeasurement (xrdml) file</td>
            <tr></tr>
            <td width="250px"><a href="loadTensor.html"><tt>loadTensor</tt></a></td>
            <td>import Tensor data   Description *loadTensor* is a high level method for importing EBSD data from external files. It autodetects
               the format of the file. As parameters the method requires a filename and the crystal and specimen @symmetry. Furthermore,
               you can specify a comment to be associated with the data. In the case of generic ascii files each of which consist of a table
               containing in each row the euler angles of a certain orientation see &lt;loadTensor_generic.html loadTensor_generic&gt; for additional
               options.  Syntax T = loadTensor(fname,cs)  Input fname     - filename cs    - crystal @symmetry  Options interface
                - specific interface to be used  Output T - @tensor
            </td>
            <tr></tr>
            <td width="250px"><a href="loadTensor_generic.html"><tt>loadTensor_generic</tt></a></td>
            <td>load a Tensor from a file  Description   *loadEBSD_generic* is a generic function that reads any ascii file containing
               a matrix like  e_11 e_12  ... e_1j .     .   ...  . .     .    .   . e_i1   .   ... e_ij  describing the a Tensor
                Syntax pf   = loadTensor_generic(fname,&lt;options&gt;)  Input fname - file name (text files only)  Options name      
                      - name of the tensor  Example  See also loadData
            </td>
            <tr></tr>
            <td width="250px"><a href="loadTensor_mpod.html"><tt>loadTensor_mpod</tt></a></td>
            <td>import Tensor data  Description *loadTensor_mod* is a high level method for importing Tensor data from external files.
               &lt;http://www.materialproperties.org/data/ Material Properties Open Database&gt;  Syntax pf = loadTensor_mpod(fname,cs,ss,&lt;options&gt;)
                Input fname     - filename cs, ss    - crystal, specimen @symmetry (optional)  Example download form MPOD T = loadTensor_mpod(1000055)
               T = loadTensor_mpod('1000055.mpod')  See also loadTensor
            </td>
            <tr></tr>
            <td width="250px"><a href="loadTensor_P.html"><tt>loadTensor_P</tt></a></td>
            <td>load a Tensor from a file  Description   *loadEBSD_generic* is a generic function that reads any ascii file containing
               a matrix like  e_11 e_12  ... e_1j .     .   ...  . .     .    .   . e_i1   .   ... e_ij  describing the a Tensor
                Syntax T   = loadTensor_generic(fname,&lt;options&gt;)  Input fname - file name (text files only)  Options name       
                     - name of the tensor  Example  See also loadData
            </td>
            <tr></tr>
            <td width="250px"><a href="loadVector3d.html"><tt>loadVector3d</tt></a></td>
            <td>import ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="loadVector3d_generic.html"><tt>loadVector3d_generic</tt></a></td>
            <td>load pole figure data from (alpha,beta,gamma) files</td>
            <tr></tr>
            <td width="250px"><a href="localOrientationGrid.html"><tt>localOrientationGrid</tt></a></td>
            <td>define a equispaced grid localized to a center orientation</td>
            <tr></tr>
            <td width="250px"><a href="tensor.logm.html"><tt>logm</tt></a><span>   (tensor)</span></td>
            <td>matrix logarithm of a tensor  Input T - @tensor  Output T - @tensor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.LSCV.html"><tt>LSCV</tt></a><span>   (orientation)</span></td>
            <td>least squares cross valiadation</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>M<a name="12"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="mat2quat.html"><tt>mat2quat</tt></a></td>
            <td>converts direction cosine matrix to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.matrix.html"><tt>matrix</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to direction cosine matrix conversion converts direction cosine matrix to quaternion  Syntax mat = matrix(q)
                Input q - @quaternion  Output mat - vector of matrixes  See also mat2quat Euler axis2quat hr2quat
            </td>
            <tr></tr>
            <td width="250px"><a href="rotation.matrix.html"><tt>matrix</tt></a><span>   (rotation)</span></td>
            <td>quaternion to direction cosine matrix conversion converts direction cosine matrix to quaternion  Syntax mat = matrix(q)
                Input  q - @quaternion  Output  mat - vector of matrixes  See also mat2quat Euler axis2quat hr2quat
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.matrix.html"><tt>matrix</tt></a><span>   (tensor)</span></td>
            <td>return tensor as a matrix  Syntax m = matrix(T) m = matrix(T,'voigt')  Input T - @tensor  Output m - matrix  Options
               voigt - give a 4 rank tensor in voigt notation, i.e. as a 6 x 6 matrix  See also
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.max.html"><tt>max</tt></a><span>   (ODF)</span></td>
            <td>heuristic to find local modal orientations  Input odf - @ODF   Output m   - maximum in multiples of the uniform ODF
               ori - @orientation where the maximum is atained  Options resolution  - search--grid resolution accuracy    - in radians
                Example find the local maxima of the [[SantaFe.html,SantaFe]] ODF  [m,ori] = max(SantaFe) plotPDF(SantaFe,Miller(0,0,1))
               annotate(ori)   See also ODF/calcModes
            </td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.max.html"><tt>max</tt></a><span>   (PoleFigure)</span></td>
            <td>maximum of two pole figures or the maximum of a single polefigure</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.max.html"><tt>max</tt></a><span>   (S1Grid)</span></td>
            <td>return maximum value</td>
            <tr></tr>
            <td width="250px"><a href="tensor.max.html"><tt>max</tt></a><span>   (tensor)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.maxAngle.html"><tt>maxAngle</tt></a><span>   (orientationRegion)</span></td>
            <td>get the maximum angle of the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.maxAngle.html"><tt>maxAngle</tt></a><span>   (symmetry)</span></td>
            <td>get the maximum angle of the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="ODF.maxpdf.html"><tt>maxpdf</tt></a><span>   (ODF)</span></td>
            <td>returns the maximum orientation in a polefigure  Input odf - @ODF h   - @Miller</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mean.html"><tt>mean</tt></a><span>   (ODF)</span></td>
            <td>returns mean, kappas  Input odf       - @ODF  Output mean      - @orientation kappa     - parameters of bingham distribution
               v         - eigenvectors
            </td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mean.html"><tt>mean</tt></a><span>   (PoleFigure)</span></td>
            <td>mean of pole figure intensities</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mean.html"><tt>mean</tt></a><span>   (orientation)</span></td>
            <td>mean of a list of orientations, principle axes and moments of inertia  Syntax [m, lambda, V, kappa, q]  = mean(o)  Input
               o        - list of @orientation  Options weights  - list of weights  Output m      - mean @orientation lambda - principle
               moments of inertia V      - principle axes of inertia (@orientation) kappa  - form parameters of bingham distribution q
                    - crystallographic equivalent @quaternion projected to fundamental region  See also BinghamODF
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mean.html"><tt>mean</tt></a><span>   (quaternion)</span></td>
            <td>mean of a list of quaternions, principle axes and moments of inertia  Input q        - list of @quaternion  Options
               weights  - list of weights  Output mean     - mean orientation lambda   - principle moments of inertia V        - principle
               axes of inertia (@orientation)  See also orientation/mean
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mean.html"><tt>mean</tt></a><span>   (vector3d)</span></td>
            <td>computes the mean vector</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mean_CS.html"><tt>mean_CS</tt></a><span>   (quaternion)</span></td>
            <td>fast mean of   Syntax m = mean(o)  Input o        - list of @orientation  Output m      - mean @orientation  See
               also orientation/mean
            </td>
            <tr></tr>
            <td width="250px"><a href="measurePoleFigure.html"><tt>measurePoleFigure</tt></a></td>
            <td>simulate a polefigure measurement  Syntax pf = measurePoleFigure(odf,h,@S2Grid,...) -  pf = measurePoleFigure(odf,h,'integral','steps',30,'drho',5*degree,...)
               - pf = measurePoleFigure(odf,h,'path',@vector3d,@vector3d,...) -   Input  Options S2Grid     - perform a point measure
               integral   - integrate over small circle while measuring mintheta/minrho - S2Grid parameter maxtheta/maxrho -  dtheta 
                -  drho     - length of integral way path       - integrate from A to B, where data is cummulated to B domega   - cummulate
               after a certain way dpoints  - fill the path A to B with d--points midpoint - cummulate to midpoint / else to endpoint of
               route steps     - number of measures
            </td>
            <tr></tr>
            <td width="250px"><a href="grain2d.merge.html"><tt>merge</tt></a><span>   (grain2d)</span></td>
            <td>merge grains along certain grain boundaries  The function merges grains where the special boundary is determined by the
               function &lt;GrainSet.specialBoundary.html specialBoundary&gt;  Input grains   - @grain2d boundary - @grainBoundary  Output
               grains_merged - @grain2d parentId      - a list of the same size as grains containing the ids of the merged grains  Example:
                mtexdata small grains = smooth(calcGrains(ebsd))  % merge all neigbouring Diopside grains gB = grains.boundary('Diopside','Diopside')
               [grains_m,parentId] = merge(grains,gB)
            </td>
            <tr></tr>
            <td width="250px"><a href="mhyper.html"><tt>mhyper</tt></a></td>
            <td>multivariat hypergeometric function 1F1(1/2,p/2, kappa)  reference: G. HILLIER, R. KAN, and X. WANG: Computationally Efficient
               Recursions for Top-Order Invariant Polynomials with Applications in Econometric Theory, 25(1), 211-242, 2009. http://www.rotman.utoronto.ca/~kan/papers/zonal5.pdf
               with many thanks to Raymond Kan
            </td>
            <tr></tr>
            <td width="250px"><a href="Miller2quat.html"><tt>Miller2quat</tt></a></td>
            <td>calculate quaternion from Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.min.html"><tt>min</tt></a><span>   (PoleFigure)</span></td>
            <td>minimum of two pole figures or the minimum of a single polefigure</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.min.html"><tt>min</tt></a><span>   (S1Grid)</span></td>
            <td>return maximum value</td>
            <tr></tr>
            <td width="250px"><a href="tensor.min.html"><tt>min</tt></a><span>   (tensor)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.minAngle.html"><tt>minAngle</tt></a><span>   (orientationRegion)</span></td>
            <td>get the minimum angle of the boundary of the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="misorientationAnalysis.mIndex.html"><tt>mIndex</tt></a><span>   (misorientationAnalysis)</span></td>
            <td>experimental angle distribution</td>
            <tr></tr>
            <td width="250px"><a href="ODF.minus.html"><tt>minus</tt></a><span>   (ODF)</span></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.minus.html"><tt>minus</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 - pf2</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.minus.html"><tt>minus</tt></a><span>   (S1Grid)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.minus.html"><tt>minus</tt></a><span>   (quaternion)</span></td>
            <td>overloads minus</td>
            <tr></tr>
            <td width="250px"><a href="tensor.minus.html"><tt>minus</tt></a><span>   (tensor)</span></td>
            <td>add two tensors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.minus.html"><tt>minus</tt></a><span>   (vector3d)</span></td>
            <td>overload minus</td>
            <tr></tr>
            <td width="250px"><a href="mix2.html"><tt>mix2</tt></a></td>
            <td>mix2 sample ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mldivide.html"><tt>mldivide</tt></a><span>   (orientation)</span></td>
            <td>o \ v</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mldivide.html"><tt>mldivide</tt></a><span>   (quaternion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="rotation.mldivide.html"><tt>mldivide</tt></a><span>   (rotation)</span></td>
            <td>o \ v</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mpower.html"><tt>mpower</tt></a><span>   (quaternion)</span></td>
            <td>q^n</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mrdivide.html"><tt>mrdivide</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mrdivide.html"><tt>mrdivide</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 ./ b and a ./ pf2  overload the .* operator, i.e. one can now write x .* pf in order to scale the @PoleFigure
               pf by the factor x   See also PoleFigure_index PoleFigure/plus PoleFigure/minus
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mrdivide.html"><tt>mrdivide</tt></a><span>   (quaternion)</span></td>
            <td>scalar division</td>
            <tr></tr>
            <td width="250px"><a href="tensor.mrdivide.html"><tt>mrdivide</tt></a><span>   (tensor)</span></td>
            <td>implements T / S</td>
            <tr></tr>
            <td width="250px"><a href="mtex_assert.html"><tt>mtex_assert</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="mtex_path.html"><tt>mtex_path</tt></a></td>
            <td>return install dir of mtex</td>
            <tr></tr>
            <td width="250px"><a href="mtexCifPath.html"><tt>mtexCifPath</tt></a></td>
            <td>returns the default path to crystallographic information files (CIF)</td>
            <tr></tr>
            <td width="250px"><a href="mtexColorbar.html"><tt>mtexColorbar</tt></a></td>
            <td>overide buildin Matlab colorbar function</td>
            <tr></tr>
            <td width="250px"><a href="mtexColorMap.html"><tt>mtexColorMap</tt></a></td>
            <td>define an MTEX colormap</td>
            <tr></tr>
            <td width="250px"><a href="mtexdata.html"><tt>mtexdata</tt></a></td>
            <td>load of data provided with mtex and often used in documentation  Syntax mtexdata        % displays a list of available
               loading routines mtexdata name   % loads specified data set  Input  Flags aachen - 3d - serial section 3d EBSD data
               from Leo Kestens mylonite - collected by Daniel Rutte (Brad R. Hacker) epidote - data provided by David Mainprice  dubna
               - collected by Florian Wobbe at Dubna ptx - geesthacht -   See also
            </td>
            <tr></tr>
            <td width="250px"><a href="mtexDataPath.html"><tt>mtexDataPath</tt></a></td>
            <td>returns the default path to mtex sample data</td>
            <tr></tr>
            <td width="250px"><a href="mtexdegchar.html"><tt>mtexdegchar</tt></a></td>
            <td>returns the degree character</td>
            <tr></tr>
            <td width="250px"><a href="mtexEBSDPath.html"><tt>mtexEBSDPath</tt></a></td>
            <td>returns the default path to EBSD data files</td>
            <tr></tr>
            <td width="250px"><a href="MTEXmenu.html"><tt>MTEXmenu</tt></a></td>
            <td>show up MTEX menu</td>
            <tr></tr>
            <td width="250px"><a href="mtexODFPath.html"><tt>mtexODFPath</tt></a></td>
            <td>returns the default path to ODF-files</td>
            <tr></tr>
            <td width="250px"><a href="mtexPoleFigurePath.html"><tt>mtexPoleFigurePath</tt></a></td>
            <td>returns the default path to PoleFigure data files</td>
            <tr></tr>
            <td width="250px"><a href="mtexTensorPath.html"><tt>mtexTensorPath</tt></a></td>
            <td>returns the default path to tensor-files</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.mtimes.html"><tt>mtimes</tt></a><span>   (EBSD)</span></td>
            <td>rotating the ebsd data by a certain rotation</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mtimes.html"><tt>mtimes</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mtimes.html"><tt>mtimes</tt></a><span>   (PoleFigure)</span></td>
            <td>scaling of PoleFigures, implements pf1 * b and a * pf2</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.mtimes.html"><tt>mtimes</tt></a><span>   (SO3Grid)</span></td>
            <td>outer quaternion multiplication</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mtimes.html"><tt>mtimes</tt></a><span>   (orientation)</span></td>
            <td>orientation times Miller and orientation times orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.mtimes.html"><tt>mtimes</tt></a><span>   (orientationRegion)</span></td>
            <td>rotate of a orientation region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mtimes.html"><tt>mtimes</tt></a><span>   (quaternion)</span></td>
            <td>quaternionen multiplication q1 * q2</td>
            <tr></tr>
            <td width="250px"><a href="rotation.mtimes.html"><tt>mtimes</tt></a><span>   (rotation)</span></td>
            <td>r = a * b</td>
            <tr></tr>
            <td width="250px"><a href="tensor.mtimes.html"><tt>mtimes</tt></a><span>   (tensor)</span></td>
            <td>implements T1 * T2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mtimes.html"><tt>mtimes</tt></a><span>   (vector3d)</span></td>
            <td>scalar multiplication</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.multiplicityPerpZ.html"><tt>multiplicityPerpZ</tt></a><span>   (symmetry)</span></td>
            <td>maximum angle rho</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.multiplicityZ.html"><tt>multiplicityZ</tt></a><span>   (symmetry)</span></td>
            <td>maximum angle rho</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>N<a name="13"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="n2str.html"><tt>n2str</tt></a></td>
            <td>num2str with exact zero</td>
            <tr></tr>
            <td width="250px"><a href="nadjacent.html"><tt>nadjacent</tt></a></td>
            <td>Returns the adjacency matrix of the n-neighbours.</td>
            <tr></tr>
            <td width="250px"><a href="nanmax.html"><tt>nanmax</tt></a></td>
            <td>FORMAT: [Y,IDX] = NANMAX(A,DIM,[B])</td>
            <tr></tr>
            <td width="250px"><a href="nanmean.html"><tt>nanmean</tt></a></td>
            <td>FORMAT: Y = NANMEAN(X,DIM)</td>
            <tr></tr>
            <td width="250px"><a href="nanmedian.html"><tt>nanmedian</tt></a></td>
            <td>FORMAT: Y = NANMEDIAN(X,DIM)</td>
            <tr></tr>
            <td width="250px"><a href="nanmin.html"><tt>nanmin</tt></a></td>
            <td>FORMAT: [Y,IDX] = NANMIN(A,DIM,[B])</td>
            <tr></tr>
            <td width="250px"><a href="nansum.html"><tt>nansum</tt></a></td>
            <td>FORMAT: Y = NANSUM(X,DIM)</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ndims.html"><tt>ndims</tt></a><span>   (quaternion)</span></td>
            <td>overloads ndims</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.ne.html"><tt>ne</tt></a><span>   (grain2d)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.ne.html"><tt>ne</tt></a><span>   (orientationRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ne.html"><tt>ne</tt></a><span>   (quaternion)</span></td>
            <td>q1 ~= q2 ?</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.ne.html"><tt>ne</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="tensor.ne.html"><tt>ne</tt></a><span>   (tensor)</span></td>
            <td>checks whether two tensors are not equal</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.ne.html"><tt>ne</tt></a><span>   (vector3d)</span></td>
            <td>? v1 == v2</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.neighbors.html"><tt>neighbors</tt></a><span>   (grain2d)</span></td>
            <td>returns the number of neighboring grains  Input grains - @GrainSet  Output counts - number of neighbors per grain pairs
                - index list of size N x 2, where   $$N = 2 \sum n_i $$ is the total number of neighborhood relations (without self--reference).
                pairs(i,:) give the indexes of two neighbored grains, i.e   neighbor_gr = grains(pairs(1,:))  selects two neighbored
               grains.
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.neuralgas.html"><tt>neuralgas</tt></a><span>   (ODF)</span></td>
            <td>attempt to distribute measure-sites equally according to invers polefigure density (experimental)  Input odf - @ODF h
                 - @Miller  Options Grid    - @S2Grid, reference Grid to evaluate PDF resolution - Grid Resolution maxtheta - max Theta
               of Grid Points  - number of Points epoches - number of Iterations eta     - 'learing--rate' as vector: [eta_start eta_stop],
               default [0.1 0.02] lambda  - stimuli of  verbose - display points during optimisation  Example S2G = neuralgas(odf,Miller(1,0,0,cs),'points',500,'epoches',25)
                See also S2Grid/refine
            </td>
            <tr></tr>
            <td width="250px"><a href="newer_version.html"><tt>newer_version</tt></a></td>
            <td>check matlab version</td>
            <tr></tr>
            <td width="250px"><a href="newMapPlot.html"><tt>newMapPlot</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="newMtexFigure.html"><tt>newMtexFigure</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="newODFSectionPlot.html"><tt>newODFSectionPlot</tt></a></td>
            <td>generate a new ODF section plot</td>
            <tr></tr>
            <td width="250px"><a href="newSphericalPlot.html"><tt>newSphericalPlot</tt></a></td>
            <td>split plot in upper and lower hemisphere  1: axis given -&gt; no sphericalRegion stored -&gt; compute sphericalRegion -&gt; finish
               2: axis is hold and has sphericalRegion -&gt; use multiplot 3: new multiplot
            </td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.nextAxis.html"><tt>nextAxis</tt></a><span>   (mtexFigure)</span></td>
            <td>go to next plot</td>
            <tr></tr>
            <td width="250px"><a href="nextstyle.html"><tt>nextstyle</tt></a></td>
            <td>NEXTSTYLE Get next plot linespec [L,C,M] = NEXTSTYLE(AX) gets the next line style, color and marker for plotting from the
               ColorOrder and LineStyleOrder of axes AX.
            </td>
            <tr></tr>
            <td width="250px"><a href="symmetry.nfold.html"><tt>nfold</tt></a><span>   (symmetry)</span></td>
            <td>maximal n-fold of symmetry axes</td>
            <tr></tr>
            <td width="250px"><a href="orientation.niceEuler.html"><tt>niceEuler</tt></a><span>   (orientation)</span></td>
            <td>orientation to euler angle</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.noisepf.html"><tt>noisepf</tt></a><span>   (PoleFigure)</span></td>
            <td>simulate diffraction counts</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.norm.html"><tt>norm</tt></a><span>   (FourierComponent)</span></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.norm.html"><tt>norm</tt></a><span>   (ODF)</span></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.norm.html"><tt>norm</tt></a><span>   (quaternion)</span></td>
            <td>quaternion norm sqrt(a^2+b^2+c^2+c^2)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.norm.html"><tt>norm</tt></a><span>   (vector3d)</span></td>
            <td>vector norm</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.normalize.html"><tt>normalize</tt></a><span>   (PoleFigure)</span></td>
            <td>normalization of a meassured pole figure with respect to an ODF</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.normalize.html"><tt>normalize</tt></a><span>   (quaternion)</span></td>
            <td>normalize quaternion</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.normalize.html"><tt>normalize</tt></a><span>   (vector3d)</span></td>
            <td>normalize a vector</td>
            <tr></tr>
            <td width="250px"><a href="tensor.numel.html"><tt>numel</tt></a><span>   (tensor)</span></td>
            <td>returns the number of tensors</td>
            <tr></tr>
            <td width="250px"><a href="NWSE.html"><tt>NWSE</tt></a></td>
            <td></td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>O<a name="14"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="option2str.html"><tt>option2str</tt></a></td>
            <td>transforms option list to comma separated list</td>
            <tr></tr>
            <td width="250px"><a href="optiondraw.html"><tt>optiondraw</tt></a></td>
            <td>apply options to handle</td>
            <tr></tr>
            <td width="250px"><a href="optionplot.html"><tt>optionplot</tt></a></td>
            <td>plot y against x using the options in varargin</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.orth.html"><tt>orth</tt></a><span>   (quaternion)</span></td>
            <td>returns a quaternion orthogonal to q1, q2, q3  Input q1, q2, q3 - @quaternions  Output q - @quaternion with dot(q,[q1,q2,q3])
               == 0
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.orth.html"><tt>orth</tt></a><span>   (vector3d)</span></td>
            <td>an arbitrary orthogonal vector</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>P<a name="15"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="parseXML.html"><tt>parseXML</tt></a></td>
            <td>PARSEXML Convert XML file to a MATLAB structure.</td>
            <tr></tr>
            <td width="250px"><a href="parulaColorMap.html"><tt>parulaColorMap</tt></a></td>
            <td>PARULA Blue-green-orange-yellow color map PARULA(M) returns an M-by-3 matrix containing a colormap.  The colors begin with
               dark purplish-blue and blue, range through green and orange, and end with bright yellow. PARULA is named after a bird, the
               tropical parula, which has these colors.
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.patchPatala.html"><tt>patchPatala</tt></a><span>   (vector3d)</span></td>
            <td>Syntax  Input  Output  Options  See also</td>
            <tr></tr>
            <td width="250px"><a href="pauseline.html"><tt>pauseline</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="vector3d.pcolor.html"><tt>pcolor</tt></a><span>   (vector3d)</span></td>
            <td>spherical contour plot  Syntax pcolor(v,data)  Input v - @vector3d data - double  See also vector3d/plot vector3d/contourf</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.pdfMatrix.html"><tt>pdfMatrix</tt></a><span>   (femComponent)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.pdfMatrix.html"><tt>pdfMatrix</tt></a><span>   (DelaunaySO3)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.perimeter.html"><tt>perimeter</tt></a><span>   (grain2d)</span></td>
            <td>calculates the perimeter of a grain, without holes  Input grains - @grain2d  Output peri - perimeter  Syntax peri
               = grains.perimeter  See also grain2d/equivalentPerimeter
            </td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.perimeter.html"><tt>perimeter</tt></a><span>   (grainBoundary)</span></td>
            <td>boundary length  Input gb - @grainBoundary  Output peri    - perimeter  Syntax p = perimeter(grains.boundary) - 
                p = perimeter(grains,10*degree) - returns the length of low angle boundaries per grain  p = perimeter(grains,CSL(3))
               - returns the length of special boundaries per grains  p = perimeter(grains,property,...,param,val,...) -  See also
               Grain2d/equivalentPerimeter
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.permute.html"><tt>permute</tt></a><span>   (quaternion)</span></td>
            <td>overloads permute</td>
            <tr></tr>
            <td width="250px"><a href="rotation.permute.html"><tt>permute</tt></a><span>   (rotation)</span></td>
            <td>overloads permute</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.perp.html"><tt>perp</tt></a><span>   (vector3d)</span></td>
            <td>conmpute an vector best orthogonal to a list of directions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.pertube.html"><tt>pertube</tt></a><span>   (quaternion)</span></td>
            <td>pertube data randomly by epsilon</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.perturbe.html"><tt>perturbe</tt></a><span>   (quaternion)</span></td>
            <td>pertube data randomly by epsilon</td>
            <tr></tr>
            <td width="250px"><a href="phi2Sections.html"><tt>phi2Sections</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="EBSD.plot.html"><tt>plot</tt></a><span>   (EBSD)</span></td>
            <td>spatial EBSD plot</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.plot.html"><tt>plot</tt></a><span>   (grain2d)</span></td>
            <td>colorize grains  Syntax plot(grains)          % colorize by phase plot(grains,property) % colorize by property  Input
               grains  - @grain2d  PatchProperty - see documentation of patch objects for manipulating the apperance, e.g. 'EdgeColor'
               See also EBSD/plot grainBoundary/plot
            </td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.plot.html"><tt>plot</tt></a><span>   (grainBoundary)</span></td>
            <td>plot grain boundaries  The function plots grain boundaries where the boundary is determined by the function &lt;GrainSet.specialBoundary.html
               specialBoundary&gt;  Input grains  - @grainBoundary  Options property - colorize a special grain boundary property, variants
               are:  * |'phase'| -- boundaries between different phases  * |'phaseTransition'|  -- colorize boundaries according to phase
               change (same phase, different phase). * |'angle'| -- misorientation angle between two neighboured ebsd measurements on
               the boundary. * |'misorientation'| -- calculate the misorientation on the grain boundary between two ebsd measurements and
               [[orientation2color.html,colorize]] it after a choosen colorcoding, i.e.  plot(grains,'property','misorientation',...
               'colorcoding','ipdfHSV')  *  @quaternion | @rotation | @orientation -- plot grain boundaries with a specified misorientation
                plot(grains,'property',... rotation('axis',zvector,'angle',60*degree))  *  @Miller | @vector3d -- plot grain boundaries
               such as specified crystallographic face are parallel. use with option 'delta'  delta - specify a searching radius for special
               grain boundary (default 5 degrees), if a orientation or crystallographic face is specified.  linecolor|edgecolor|facecolor
               - color of the boundary  linewidth - width of the line  Flags internal - only plot boundaries within a grain which do
               not match the grain boundary criterion external - only plot grain--boundaries to other grains.  See also GrainSet/specialBoundary
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.plot.html"><tt>plot</tt></a><span>   (ODF)</span></td>
            <td>plots odf</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plot.html"><tt>plot</tt></a><span>   (PoleFigure)</span></td>
            <td>plot pole figure</td>
            <tr></tr>
            <td width="250px"><a href="ODFSections.plot.html"><tt>plot</tt></a><span>   (ODFSections)</span></td>
            <td>plot data into ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.plot.html"><tt>plot</tt></a><span>   (S1Grid)</span></td>
            <td>plot grid</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plot.html"><tt>plot</tt></a><span>   (orientation)</span></td>
            <td>annotate a orientation to an existing plot</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.plot.html"><tt>plot</tt></a><span>   (orientationRegion)</span></td>
            <td>plots a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.plot.html"><tt>plot</tt></a><span>   (quaternion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.plot.html"><tt>plot</tt></a><span>   (sphericalRegion)</span></td>
            <td>plots a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.plot.html"><tt>plot</tt></a><span>   (symmetry)</span></td>
            <td>plot symmetry</td>
            <tr></tr>
            <td width="250px"><a href="tensor.plot.html"><tt>plot</tt></a><span>   (tensor)</span></td>
            <td>plot a tensor T  Input T - @tensor  Options plotType - directionalMagnitude YoungsModulus linearCompressibility velocity'
               3d - plot surface of plotType instead of spherical projection section - plot a section  -- @vector3d - of given plane normal
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plot.html"><tt>plot</tt></a><span>   (vector3d)</span></td>
            <td>plot three dimensional vector</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plot.html"><tt>plot</tt></a><span>   (kernel)</span></td>
            <td>plot the kernel function</td>
            <tr></tr>
            <td width="250px"><a href="patalaOrientationMapping.plot.html"><tt>plot</tt></a><span>   (patalaOrientationMapping)</span></td>
            <td>plot colorbar with patala misorientation colorcoding</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plot3d.html"><tt>plot3d</tt></a><span>   (ODF)</span></td>
            <td>plots odf</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plot3d.html"><tt>plot3d</tt></a><span>   (vector3d)</span></td>
            <td>plot spherical data</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plot_zero_range.html"><tt>plot_zero_range</tt></a><span>   (PoleFigure)</span></td>
            <td>implements the zero range method</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a><span>   (EBSD)</span></td>
            <td>plot uncorelated angle distribution for all pairs of phases  Input ebsd - @EBSD  Flags ODF, MDF - compute the uncorrelated
               angle distribution from the MDF  See also orientation/calcAngleDistribution
            </td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a><span>   (grainBoundary)</span></td>
            <td>plot uncorelated angle distribution for all pairs of phases  Input gB - @grainBoundary  See also orientation/calcAngleDistribution</td>
            <tr></tr>
            <td width="250px"><a href="misorientationAnalysis.plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a><span>   (misorientationAnalysis)</span></td>
            <td>plot the angle distribution  Input ebsd - @EBSD grains - @grainSet  Flags ODF, MDF     - compute the uncorrelated angle
               distribution from the MDF uncorrelated - compute the uncorrelated angle distribution from the EBSD data  See also EBSD/calcAngleDistribution
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a><span>   (ODF)</span></td>
            <td>plot axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a><span>   (orientation)</span></td>
            <td>plot the angle distribution  Input ori - @orientation n   - number of bins  See also orientation/plotAxisDistribution</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a><span>   (symmetry)</span></td>
            <td>plot axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.plotAxisDistribution.html"><tt>plotAxisDistribution</tt></a><span>   (EBSD)</span></td>
            <td>plot uncorrelated axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.plotAxisDistribution.html"><tt>plotAxisDistribution</tt></a><span>   (grainBoundary)</span></td>
            <td>plot uncorelated angle distribution for all pairs of phases  Input gB - @grainBoundary  See also orientation/calcAngleDistribution</td>
            <tr></tr>
            <td width="250px"><a href="misorientationAnalysis.plotAxisDistribution.html"><tt>plotAxisDistribution</tt></a><span>   (misorientationAnalysis)</span></td>
            <td>plot uncorrelated axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotAxisDistribution.html"><tt>plotAxisDistribution</tt></a><span>   (orientation)</span></td>
            <td>plot uncorrelated axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="plotAxisDistribution.html"><tt>plotAxisDistribution</tt></a></td>
            <td>plot axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plotCustom.html"><tt>plotCustom</tt></a><span>   (vector3d)</span></td>
            <td>Syntax plotcustom(v,@(x,y) drawCommand(x,y))  %  Input v  - @vector3d s  - string  Options  Output  See also</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotDiff.html"><tt>plotDiff</tt></a><span>   (ODF)</span></td>
            <td>difference plot between two odfs or an odf and a pole figure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plotDiff.html"><tt>plotDiff</tt></a><span>   (PoleFigure)</span></td>
            <td>difference plot between two pole figures or an odf and a pole figure</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotFibre.html"><tt>plotFibre</tt></a><span>   (ODF)</span></td>
            <td>plot odf along a fibre</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotFourier.html"><tt>plotFourier</tt></a><span>   (ODF)</span></td>
            <td>plots Fourier coefficients of the odf</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plotFourier.html"><tt>plotFourier</tt></a><span>   (kernel)</span></td>
            <td>plot the Chybeyshev coefficients of the kernel function</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.plotHKL.html"><tt>plotHKL</tt></a><span>   (crystalSymmetry)</span></td>
            <td>plot symmetry</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotIPDF.html"><tt>plotIPDF</tt></a><span>   (ODF)</span></td>
            <td>plot inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotIPDF.html"><tt>plotIPDF</tt></a><span>   (orientation)</span></td>
            <td>plot orientations into inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotODF.html"><tt>plotODF</tt></a><span>   (ODF)</span></td>
            <td>plot ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotODF.html"><tt>plotODF</tt></a><span>   (orientation)</span></td>
            <td>plot orientations to ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotPDF.html"><tt>plotPDF</tt></a><span>   (ODF)</span></td>
            <td>plot pole figures</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotPDF.html"><tt>plotPDF</tt></a><span>   (orientation)</span></td>
            <td>plot orientations into pole figures</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plotPDF.html"><tt>plotPDF</tt></a><span>   (kernel)</span></td>
            <td>plot Radon transformed kernel</td>
            <tr></tr>
            <td width="250px"><a href="tensor.plotS2Grid.html"><tt>plotS2Grid</tt></a><span>   (tensor)</span></td>
            <td>define a plotting grid suitable for tensor plots</td>
            <tr></tr>
            <td width="250px"><a href="plotS2Grid.html"><tt>plotS2Grid</tt></a></td>
            <td>create a regular S2Grid for plotting</td>
            <tr></tr>
            <td width="250px"><a href="plotSO3Grid.html"><tt>plotSO3Grid</tt></a></td>
            <td>give a regular grid in orientation space</td>
            <tr></tr>
            <td width="250px"><a href="plotx2east.html"><tt>plotx2east</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2north.html"><tt>plotx2north</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2south.html"><tt>plotx2south</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2west.html"><tt>plotx2west</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotzIntoPlane.html"><tt>plotzIntoPlane</tt></a></td>
            <td>set the default plot direction of the z-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotzOutOfPlane.html"><tt>plotzOutOfPlane</tt></a></td>
            <td>set the default plot direction of the z-axis</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plus.html"><tt>plus</tt></a><span>   (ODF)</span></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plus.html"><tt>plus</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 + pf2</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.plus.html"><tt>plus</tt></a><span>   (S1Grid)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.plus.html"><tt>plus</tt></a><span>   (quaternion)</span></td>
            <td>pointwise addition</td>
            <tr></tr>
            <td width="250px"><a href="tensor.plus.html"><tt>plus</tt></a><span>   (tensor)</span></td>
            <td>add two tensors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plus.html"><tt>plus</tt></a><span>   (vector3d)</span></td>
            <td>poitwise addition</td>
            <tr></tr>
            <td width="250px"><a href="tensor.PoissonRatio.html"><tt>PoissonRatio</tt></a><span>   (tensor)</span></td>
            <td>computes the Poisson ratio of an elasticity tensor  Input C - elastic compliance @tensor x - @vector3d y - @vector3d
                Output nu - Poisson ratio in directions x and y  Remarks  $$\nu = \frac{-S_{ijkl} x_i x_j y_k y_l}{S_{mnop} x_m x_n
               x_o x_p}$$
            </td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.polar.html"><tt>polar</tt></a><span>   (S2Grid)</span></td>
            <td>polar coordinates of S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.polar.html"><tt>polar</tt></a><span>   (vector3d)</span></td>
            <td>cartesian to spherical coordinates Input v - @vector3d Output theta  - polar angle rho    - azimuthal angle  r      - radius</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.polarCoordinates.html"><tt>polarCoordinates</tt></a><span>   (sphericalRegion)</span></td>
            <td>compute polar coordinates of with respect to a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.power.html"><tt>power</tt></a><span>   (quaternion)</span></td>
            <td>q.^n</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.principalComponents.html"><tt>principalComponents</tt></a><span>   (grain2d)</span></td>
            <td>returns the principalcomponents of grain polygon, without Holes  Input grains - @grain2d  Output cmp   - angle of components
               as complex v     - length of axis   See also polygon/hullprincipalcomponents grain/plotEllipse
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.prod.html"><tt>prod</tt></a><span>   (quaternion)</span></td>
            <td>overloads q1 * q2 * q3</td>
            <tr></tr>
            <td width="250px"><a href="progress.html"><tt>progress</tt></a></td>
            <td>display progress</td>
            <tr></tr>
            <td width="250px"><a href="ODFSections.project.html"><tt>project</tt></a><span>   (ODFSections)</span></td>
            <td>project orientation to ODF sections used by plotODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.project2EulerFR.html"><tt>project2EulerFR</tt></a><span>   (orientation)</span></td>
            <td>projects orientation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.project2EulerFR.html"><tt>project2EulerFR</tt></a><span>   (quaternion)</span></td>
            <td>projects quaternions to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="Miller.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (Miller)</span></td>
            <td>projects vectors to the fundamental sector of the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="orientation.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (orientation)</span></td>
            <td>projects orientation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (quaternion)</span></td>
            <td>projects quaternions to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="rotation.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (rotation)</span></td>
            <td>projects rotation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (vector3d)</span></td>
            <td>projects vectors to the fundamental sector of the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.properGroup.html"><tt>properGroup</tt></a><span>   (symmetry)</span></td>
            <td>return the corresponding Laue group</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>Q<a name="16"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="quaternion.qmatrix.html"><tt>qmatrix</tt></a><span>   (quaternion)</span></td>
            <td>returns the quaternion multiplication matrix</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.qq.html"><tt>qq</tt></a><span>   (quaternion)</span></td>
            <td>returns w * q' * q  Input q - list of quaternions w - list of weights</td>
            <tr></tr>
            <td width="250px"><a href="orientation.qqplot.html"><tt>qqplot</tt></a><span>   (orientation)</span></td>
            <td>quantile-quantile of misorientation angle against random angular misorientation  Example  qqplot(SO3Grid(2.5*degree,crystalSymmetry('m-3m')))</td>
            <tr></tr>
            <td width="250px"><a href="tensor.quadric.html"><tt>quadric</tt></a><span>   (tensor)</span></td>
            <td>quadric</td>
            <tr></tr>
            <td width="250px"><a href="ODF.quantile.html"><tt>quantile</tt></a><span>   (ODF)</span></td>
            <td>quantile orientations of an ODF  Syntax SO3 = quantile(odf,p,&lt;options&gt;)  Input odf - @ODF p   - upper quantile, if
               negative lower quantile  See Also PoleFigure/quantile
            </td>
            <tr></tr>
            <td width="250px"><a href="quantile.html"><tt>quantile</tt></a></td>
            <td>n percent quantile of x</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.quiver.html"><tt>quiver</tt></a><span>   (vector3d)</span></td>
            <td>Syntax quiver(v,d)  Input v - @vector3d d - @vector3d    Options arrowSize     - length of the arrow autoArrowSize
               - automatically determine the length of the arrow MaxHeadSize   - size of the head  Output  See also
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.quiverGrid.html"><tt>quiverGrid</tt></a><span>   (tensor)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="qwarning.html"><tt>qwarning</tt></a></td>
            <td>warning with option to stop</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>R<a name="17"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="randp.html"><tt>randp</tt></a></td>
            <td>randp(lambda) returns Poisson distributed Vector with mean lambda</td>
            <tr></tr>
            <td width="250px"><a href="randq.html"><tt>randq</tt></a></td>
            <td>returns random quaternions</td>
            <tr></tr>
            <td width="250px"><a href="randv.html"><tt>randv</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="range.html"><tt>range</tt></a></td>
            <td>RANGE  Sample range. Y = RANGE(X) returns the range of the values in X.  For a vector input, Y is the difference between the
               maximum and minimum values.  For a matrix input, Y is a vector containing the range for each column.  For N-D arrays, RANGE
               operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.rdivide.html"><tt>rdivide</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rdivide.html"><tt>rdivide</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 ./ b and a ./ pf2  overload the .* operator, i.e. one can now write x .* pf in order to scale the @PoleFigure
               pf by the factor x   See also PoleFigure_index PoleFigure/plus PoleFigure/minus
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.rdivide.html"><tt>rdivide</tt></a><span>   (quaternion)</span></td>
            <td>scalar division</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rdivide.html"><tt>rdivide</tt></a><span>   (tensor)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rdivide.html"><tt>rdivide</tt></a><span>   (vector3d)</span></td>
            <td>scalar division</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.real.html"><tt>real</tt></a><span>   (quaternion)</span></td>
            <td>real-part of of quaternion</td>
            <tr></tr>
            <td width="250px"><a href="tensor.real.html"><tt>real</tt></a><span>   (tensor)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="red2blueColorMap.html"><tt>red2blueColorMap</tt></a></td>
            <td>creates a colormap, ranging from dark blue via white to dark red.</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.refine.html"><tt>refine</tt></a><span>   (DelaunaySO3)</span></td>
            <td>step 1: compute center of any two orientation connected by an edge</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.refine.html"><tt>refine</tt></a><span>   (S1Grid)</span></td>
            <td>refine S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.refine.html"><tt>refine</tt></a><span>   (S2Grid)</span></td>
            <td>refine S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.refine.html"><tt>refine</tt></a><span>   (vector3d)</span></td>
            <td>refine vectors</td>
            <tr></tr>
            <td width="250px"><a href="reflection.html"><tt>reflection</tt></a></td>
            <td>defines a reflection at plane with normal n</td>
            <tr></tr>
            <td width="250px"><a href="Miller.region.html"><tt>region</tt></a><span>   (Miller)</span></td>
            <td>return spherical region associated to a set of crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.region.html"><tt>region</tt></a><span>   (vector3d)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="regularS2Grid.html"><tt>regularS2Grid</tt></a></td>
            <td>Syntax regularS2Grid('points',[72 19]) regularS2Grid('resolution',[5*degree 2.5*degree]) regularS2Grid('theta',theta,'rho',rho)</td>
            <tr></tr>
            <td width="250px"><a href="regularSO3Grid.html"><tt>regularSO3Grid</tt></a></td>
            <td>give a regular grid in orientation space</td>
            <tr></tr>
            <td width="250px"><a href="rep.html"><tt>rep</tt></a></td>
            <td>implements R like "rep" elementeweise</td>
            <tr></tr>
            <td width="250px"><a href="repcell.html"><tt>repcell</tt></a></td>
            <td>equivalent to repmat for cells</td>
            <tr></tr>
            <td width="250px"><a href="repentry.html"><tt>repentry</tt></a></td>
            <td>reshape by element</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.repmat.html"><tt>repmat</tt></a><span>   (quaternion)</span></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="rotation.repmat.html"><tt>repmat</tt></a><span>   (rotation)</span></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.repmat.html"><tt>repmat</tt></a><span>   (vector3d)</span></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.reshape.html"><tt>reshape</tt></a><span>   (quaternion)</span></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="rotation.reshape.html"><tt>reshape</tt></a><span>   (rotation)</span></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.reshape.html"><tt>reshape</tt></a><span>   (vector3d)</span></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.restrict2Lower.html"><tt>restrict2Lower</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.restrict2Upper.html"><tt>restrict2Upper</tt></a><span>   (sphericalRegion)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="restrictEBSD_ang.html"><tt>restrictEBSD_ang</tt></a></td>
            <td>read file header</td>
            <tr></tr>
            <td width="250px"><a href="rhoInside.html"><tt>rhoInside</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.rhoRange.html"><tt>rhoRange</tt></a><span>   (sphericalRegion)</span></td>
            <td>compute range of the polar angle of a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="kernel.RK_symmetrised.html"><tt>RK_symmetrised</tt></a><span>   (kernel)</span></td>
            <td>sum Radon trasformed kernel</td>
            <tr></tr>
            <td width="250px"><a href="rmallappdata.html"><tt>rmallappdata</tt></a></td>
            <td>removes all figure appdata</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.Rodrigues.html"><tt>Rodrigues</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to rodrigues representation</td>
            <tr></tr>
            <td width="250px"><a href="rodrigues2quat.html"><tt>rodrigues2quat</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="EBSD.rotate.html"><tt>rotate</tt></a><span>   (EBSD)</span></td>
            <td>rotate EBSD orientations or spatial data around point of origin</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.rotate.html"><tt>rotate</tt></a><span>   (BinghamComponent)</span></td>
            <td>rotate component</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.rotate.html"><tt>rotate</tt></a><span>   (FourierComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="ODF.rotate.html"><tt>rotate</tt></a><span>   (ODF)</span></td>
            <td>rotate ODF</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.rotate.html"><tt>rotate</tt></a><span>   (femComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.rotate.html"><tt>rotate</tt></a><span>   (fibreComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.rotate.html"><tt>rotate</tt></a><span>   (uniformComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.rotate.html"><tt>rotate</tt></a><span>   (unimodalComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rotate.html"><tt>rotate</tt></a><span>   (PoleFigure)</span></td>
            <td>rotates pole figures by a certain rotation</td>
            <tr></tr>
            <td width="250px"><a href="Miller.rotate.html"><tt>rotate</tt></a><span>   (Miller)</span></td>
            <td>rotate crystal directions  Input m - @Miller ori - @orientation  Output v - vector3d</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.rotate.html"><tt>rotate</tt></a><span>   (orientationRegion)</span></td>
            <td>rotate of a orientation region</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.rotate.html"><tt>rotate</tt></a><span>   (sphericalRegion)</span></td>
            <td>rotate of a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rotate.html"><tt>rotate</tt></a><span>   (tensor)</span></td>
            <td>rotate a tensor by a list of rotations  Description  $$T_{rst} = T_{ijk} R_{ri} R_{sj} R_{tk}$$  Input T - @tensor
               R - @rotation or rotation matrix or a list of them  Output T - rotated @tensor
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rotate.html"><tt>rotate</tt></a><span>   (vector3d)</span></td>
            <td>rotate vector3d by quaternion</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.rotation_special.html"><tt>rotation_special</tt></a><span>   (symmetry)</span></td>
            <td>returns symmetry elements different from rotation about c-axis</td>
            <tr></tr>
            <td width="250px"><a href="Miller.round.html"><tt>round</tt></a><span>   (Miller)</span></td>
            <td>tries to round miller indizes to greatest common divisor</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>S<a name="18"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="SantaFe.html"><tt>SantaFe</tt></a></td>
            <td>the SantaFe-sample ODF</td>
            <tr></tr>
            <td width="250px"><a href="save_sparse.html"><tt>save_sparse</tt></a></td>
            <td>convert sparse matrix to jc, ir, pr</td>
            <tr></tr>
            <td width="250px"><a href="saveEBSD_hdf5.html"><tt>saveEBSD_hdf5</tt></a></td>
            <td>Save EBSD object to HDF5 format</td>
            <tr></tr>
            <td width="250px"><a href="saveFigure.html"><tt>saveFigure</tt></a></td>
            <td>save figure as grafik file</td>
            <tr></tr>
            <td width="250px"><a href="saveGrainSet_hdf5.html"><tt>saveGrainSet_hdf5</tt></a></td>
            <td>Save GrainSet object to HDF5 format</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.scale.html"><tt>scale</tt></a><span>   (PoleFigure)</span></td>
            <td>scale polefigure by a factor</td>
            <tr></tr>
            <td width="250px"><a href="Miller.scatter.html"><tt>scatter</tt></a><span>   (Miller)</span></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="orientation.scatter.html"><tt>scatter</tt></a><span>   (orientation)</span></td>
            <td>plots ebsd data as scatter plot</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.scatter.html"><tt>scatter</tt></a><span>   (quaternion)</span></td>
            <td>plot function</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.scatter.html"><tt>scatter</tt></a><span>   (vector3d)</span></td>
            <td>Syntax scatter(v)              % scatter(v,data)         % scatter(v,text)  Input v     - @vector3d data  - double
               rgb   - a list of rgb color values  Options Marker            -  MarkerFaceColor   - MarkerEdgeColor   -  MarkerColor
                     - shortcut for the above two MarkerSize        - size of the markers in pixel DynamicMarkerSize - scale marker size
               when plot is resized  Output  See also
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.scatter3d.html"><tt>scatter3d</tt></a><span>   (vector3d)</span></td>
            <td>plot spherical data</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.SchmidTensor.html"><tt>SchmidTensor</tt></a><span>   (vector3d)</span></td>
            <td>computes the Schmidt tensor</td>
            <tr></tr>
            <td width="250px"><a href="sectionLabels.html"><tt>sectionLabels</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.segLength.html"><tt>segLength</tt></a><span>   (grainBoundary)</span></td>
            <td>length of a boundary segment  Input gb - @grainBoundary  Output l - length of the boundary segments</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.select.html"><tt>select</tt></a><span>   (PoleFigure)</span></td>
            <td>select PoleFigures</td>
            <tr></tr>
            <td width="250px"><a href="selectMaxbyColumn.html"><tt>selectMaxbyColumn</tt></a></td>
            <td>find maximum in each row</td>
            <tr></tr>
            <td width="250px"><a href="selectMaxbyRow.html"><tt>selectMaxbyRow</tt></a></td>
            <td>find maximum in each column</td>
            <tr></tr>
            <td width="250px"><a href="selectMinbyColumn.html"><tt>selectMinbyColumn</tt></a></td>
            <td>find minimum in each column</td>
            <tr></tr>
            <td width="250px"><a href="selectMinbyRow.html"><tt>selectMinbyRow</tt></a></td>
            <td>find minimum in each row</td>
            <tr></tr>
            <td width="250px"><a href="selectPolygon.html"><tt>selectPolygon</tt></a></td>
            <td>select a polygon by mouse</td>
            <tr></tr>
            <td width="250px"><a href="set_default_option.html"><tt>set_default_option</tt></a></td>
            <td>set option in option list if not yet present</td>
            <tr></tr>
            <td width="250px"><a href="set_option.html"><tt>set_option</tt></a></td>
            <td>set option in option list</td>
            <tr></tr>
            <td width="250px"><a href="set_option_property.html"><tt>set_option_property</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="setCamera.html"><tt>setCamera</tt></a></td>
            <td>set Camera according to xAxis and zAxis position</td>
            <tr></tr>
            <td width="250px"><a href="setColorRange.html"><tt>setColorRange</tt></a></td>
            <td>set color range for figures</td>
            <tr></tr>
            <td width="250px"><a href="setMTEXpref.html"><tt>setMTEXpref</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="setNull.html"><tt>setNull</tt></a></td>
            <td>set approx zero to exact zero</td>
            <tr></tr>
            <td width="250px"><a href="setOption.html"><tt>setOption</tt></a></td>
            <td>set option in option list</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.setSubSet.html"><tt>setSubSet</tt></a><span>   (quaternion)</span></td>
            <td>indexing of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.shapeFactor.html"><tt>shapeFactor</tt></a><span>   (grain2d)</span></td>
            <td>calculates the shapefactor of the grain-polygon, without Holes  define as  $$ F = \frac{P}{EP} $$,  where $P$ is the
               [[Grain2d.perimeter.html,perimeter]] and  $EP$ is the [[Grain2d.equivalentPerimeter.html,equivalent perimeter]].  Input
               p - @grain2d  Output F    - shapefactor  See also polygon/aspectRatio polygon/equivalentPerimeter polygon/perimeter
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.shearModulus.html"><tt>shearModulus</tt></a><span>   (tensor)</span></td>
            <td>shear modulus for an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.shift.html"><tt>shift</tt></a><span>   (EBSD)</span></td>
            <td>shift spatial ebsd-data about (x,y)  Input ebsd - @EBSD xy   - coordinates  Output shifted ebsd - @EBSD</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.shift.html"><tt>shift</tt></a><span>   (S1Grid)</span></td>
            <td>shifts S1Grid by delta</td>
            <tr></tr>
            <td width="250px"><a href="sigmaSections.html"><tt>sigmaSections</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="quaternion.size.html"><tt>size</tt></a><span>   (quaternion)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="tensor.size.html"><tt>size</tt></a><span>   (tensor)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.size.html"><tt>size</tt></a><span>   (vector3d)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="size2str.html"><tt>size2str</tt></a></td>
            <td>convert size to string</td>
            <tr></tr>
            <td width="250px"><a href="ODF.slope.html"><tt>slope</tt></a><span>   (ODF)</span></td>
            <td>| grad(r) |</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.smooth.html"><tt>smooth</tt></a><span>   (grain2d)</span></td>
            <td>constraint laplacian smoothing of grains</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.smooth.html"><tt>smooth</tt></a><span>   (BinghamComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.smooth.html"><tt>smooth</tt></a><span>   (FourierComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="ODF.smooth.html"><tt>smooth</tt></a><span>   (ODF)</span></td>
            <td>smooth ODF</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.smooth.html"><tt>smooth</tt></a><span>   (femComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.smooth.html"><tt>smooth</tt></a><span>   (fibreComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.smooth.html"><tt>smooth</tt></a><span>   (uniformComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.smooth.html"><tt>smooth</tt></a><span>   (unimodalComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="Miller.smooth.html"><tt>smooth</tt></a><span>   (Miller)</span></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.smooth.html"><tt>smooth</tt></a><span>   (vector3d)</span></td>
            <td>Syntax  Input  Output  Options  See also</td>
            <tr></tr>
            <td width="250px"><a href="SobolevKernel.html"><tt>SobolevKernel</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="sparseConcat.html"><tt>sparseConcat</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="EBSD.spatialProfile.html"><tt>spatialProfile</tt></a><span>   (EBSD)</span></td>
            <td>select EBSD data along line segments  Syntax % returns a sorted list of ebsd data along lineX [ebsd_lineX,dist] = spatialProfile(ebsd,lineX)
                Input ebsd  - @EBSD lineX - list of spatial coordinates |[x(:) y(:)]| of if 3d |[x(:) y(:) z(:)]|,  where $x_i,x_{i+1}$
               defines a line segment  Output ebsd - @EBSD restrcited to the line of interest dist - double distance along the line to
               the initial point  Example  mtexdata twins plot(ebsd('indexed'),ebsd('indexed').orientations) lineX = ginput(2) ebsd_lineX
               = spatialProfile(ebsd,lineX) clf; plot(ebsd_lineX.x,angle(ebsd_lineX(1).orientations,ebsd_lineX.orientations)) xlabel('x'),
               ylabel('misorientation angle')
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.sphereVolume.html"><tt>sphereVolume</tt></a><span>   (orientation)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="sphericalClebschGordan.html"><tt>sphericalClebschGordan</tt></a></td>
            <td>use global wigner3j</td>
            <tr></tr>
            <td width="250px"><a href="sphericalY.html"><tt>sphericalY</tt></a></td>
            <td>spherical harmonics of degree l</td>
            <tr></tr>
            <td width="250px"><a href="splitdata.html"><tt>splitdata</tt></a></td>
            <td>make n - partitions of a list, returns its indices</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.spy.html"><tt>spy</tt></a><span>   (SO3Grid)</span></td>
            <td>spy distance matrix</td>
            <tr></tr>
            <td width="250px"><a href="SquareSingularityKernel.html"><tt>SquareSingularityKernel</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="string2Miller.html"><tt>string2Miller</tt></a></td>
            <td>converts string to Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.subGrid.html"><tt>subGrid</tt></a><span>   (S1Grid)</span></td>
            <td>epsilon - neighborhood of a point in the grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subGrid.html"><tt>subGrid</tt></a><span>   (S2Grid)</span></td>
            <td>subgrid</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subGrid.html"><tt>subGrid</tt></a><span>   (SO3Grid)</span></td>
            <td>sub-SO3Grid as epsilon neigborhood of a node</td>
            <tr></tr>
            <td width="250px"><a href="submatrix.html"><tt>submatrix</tt></a></td>
            <td>B = A(ind) with size as A if possible</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subSample.html"><tt>subSample</tt></a><span>   (EBSD)</span></td>
            <td>subsample of ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsasgn.html"><tt>subsasgn</tt></a><span>   (EBSD)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.subsasgn.html"><tt>subsasgn</tt></a><span>   (grain2d)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.subsasgn.html"><tt>subsasgn</tt></a><span>   (grainBoundary)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.subsasgn.html"><tt>subsasgn</tt></a><span>   (PoleFigure)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subsasgn.html"><tt>subsasgn</tt></a><span>   (S2Grid)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subsasgn.html"><tt>subsasgn</tt></a><span>   (SO3Grid)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subsasgn.html"><tt>subsasgn</tt></a><span>   (quaternion)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subsasgn.html"><tt>subsasgn</tt></a><span>   (rotation)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="tensor.subsasgn.html"><tt>subsasgn</tt></a><span>   (tensor)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subsasgn.html"><tt>subsasgn</tt></a><span>   (vector3d)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subSet.html"><tt>subSet</tt></a><span>   (EBSD)</span></td>
            <td>indexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.subSet.html"><tt>subSet</tt></a><span>   (grain2d)</span></td>
            <td>Input grains - @grainSet ind    -</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.subSet.html"><tt>subSet</tt></a><span>   (grainBoundary)</span></td>
            <td>restrict boundary</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subSet.html"><tt>subSet</tt></a><span>   (quaternion)</span></td>
            <td>indexing of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subSet.html"><tt>subSet</tt></a><span>   (rotation)</span></td>
            <td>indexing of rotation</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subSet.html"><tt>subSet</tt></a><span>   (vector3d)</span></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsref.html"><tt>subsref</tt></a><span>   (EBSD)</span></td>
            <td>indexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.subsref.html"><tt>subsref</tt></a><span>   (grain2d)</span></td>
            <td>access subsets of a GrainSet  Syntax grains(1:10)          % the 10 first grains of a GrainSet grains('Fe')          %
               only Fe grains grains( ~grains('fe') ) % all grains but Fe logical array with size of the complete GrainSet
            </td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.subsref.html"><tt>subsref</tt></a><span>   (grainBoundary)</span></td>
            <td>access subsets of a GrainSet  Syntax gB(1:10)               % the 10 first boundaries gB('Forsterite','Epidote')  % only
               Forsterite - Epidote boundaries grains( ~grains('fe') ) % all grains but Fe logical array with size of the complete GrainSet
            </td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.subsref.html"><tt>subsref</tt></a><span>   (PoleFigure)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subsref.html"><tt>subsref</tt></a><span>   (S2Grid)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subsref.html"><tt>subsref</tt></a><span>   (SO3Grid)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subsref.html"><tt>subsref</tt></a><span>   (quaternion)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subsref.html"><tt>subsref</tt></a><span>   (rotation)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.subsref.html"><tt>subsref</tt></a><span>   (symmetry)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="tensor.subsref.html"><tt>subsref</tt></a><span>   (tensor)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subsref.html"><tt>subsref</tt></a><span>   (vector3d)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.sum.html"><tt>sum</tt></a><span>   (quaternion)</span></td>
            <td>overloads sum</td>
            <tr></tr>
            <td width="250px"><a href="tensor.sum.html"><tt>sum</tt></a><span>   (tensor)</span></td>
            <td>sum over all tensors allong dimension 1</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.sum.html"><tt>sum</tt></a><span>   (vector3d)</span></td>
            <td>sum of vectors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.surf.html"><tt>surf</tt></a><span>   (vector3d)</span></td>
            <td>Syntax  Input  Output  Options  See also</td>
            <tr></tr>
            <td width="250px"><a href="switchUnit.html"><tt>switchUnit</tt></a></td>
            <td>returns the closest length to a known unit. For example, 10e3m will give 10km.  Syntax [fval funit] = closest_value(val,
               unit)  Input val  - a value unit - unit of the value (e.g. nm, m, ...)  Output oval  - output value  ounit - output
               unit
            </td>
            <tr></tr>
            <td width="250px"><a href="Miller.symmetrise.html"><tt>symmetrise</tt></a><span>   (Miller)</span></td>
            <td>directions symmetrically equivalent to m</td>
            <tr></tr>
            <td width="250px"><a href="orientation.symmetrise.html"><tt>symmetrise</tt></a><span>   (orientation)</span></td>
            <td>all crystallographically equivalent orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.symmetrise.html"><tt>symmetrise</tt></a><span>   (quaternion)</span></td>
            <td>symmetrcially equivalent orientations</td>
            <tr></tr>
            <td width="250px"><a href="tensor.symmetrise.html"><tt>symmetrise</tt></a><span>   (tensor)</span></td>
            <td>symmetrise a tensor according to its crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.symmetrise.html"><tt>symmetrise</tt></a><span>   (vector3d)</span></td>
            <td>symmetrcially equivalent directions and its multiple</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>T<a name="19"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="tensor.tensorSize.html"><tt>tensorSize</tt></a><span>   (tensor)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="Miller.text.html"><tt>text</tt></a><span>   (Miller)</span></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.text.html"><tt>text</tt></a><span>   (vector3d)</span></td>
            <td>display a text in a spherical plot  Syntax text(v,s)  %  Input v  - @vector3d s  - string  Options  See also</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.text3.html"><tt>text3</tt></a><span>   (vector3d)</span></td>
            <td>plot three dimensional arrows</td>
            <tr></tr>
            <td width="250px"><a href="ODF.textureindex.html"><tt>textureindex</tt></a><span>   (ODF)</span></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.times.html"><tt>times</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.times.html"><tt>times</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 .* b and a .* pf2</td>
            <tr></tr>
            <td width="250px"><a href="orientation.times.html"><tt>times</tt></a><span>   (orientation)</span></td>
            <td>vec = ori .* Miller</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.times.html"><tt>times</tt></a><span>   (quaternion)</span></td>
            <td>implements quaternion .* quaternion and quaternion .* vector3d</td>
            <tr></tr>
            <td width="250px"><a href="rotation.times.html"><tt>times</tt></a><span>   (rotation)</span></td>
            <td>r = a .* b</td>
            <tr></tr>
            <td width="250px"><a href="tensor.times.html"><tt>times</tt></a><span>   (tensor)</span></td>
            <td>multiply a tensor by a scalar</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.times.html"><tt>times</tt></a><span>   (vector3d)</span></td>
            <td>.* - componenwtise multiplication</td>
            <tr></tr>
            <td width="250px"><a href="times_outer.html"><tt>times_outer</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="tensor.transform.html"><tt>transform</tt></a><span>   (tensor)</span></td>
            <td>transform a tensor to a given crystal frame</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.transformationMatrix.html"><tt>transformationMatrix</tt></a><span>   (crystalSymmetry)</span></td>
            <td>compute the transformation matrix from cs1 to cs2</td>
            <tr></tr>
            <td width="250px"><a href="Miller.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a><span>   (Miller)</span></td>
            <td>change reference frame while keeping hkl or uvw</td>
            <tr></tr>
            <td width="250px"><a href="orientation.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a><span>   (orientation)</span></td>
            <td>only applicable for crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="tensor.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a><span>   (tensor)</span></td>
            <td>set properties of a tensor variable  Syntax T = set(T,'mineral','mineral name')    Input T      - @tensor pName  -
               property name pValue - property value  Output  See also tensor/get
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.transpose.html"><tt>transpose</tt></a><span>   (quaternion)</span></td>
            <td>transpose array of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.transpose.html"><tt>transpose</tt></a><span>   (rotation)</span></td>
            <td>transpose array of rotations</td>
            <tr></tr>
            <td width="250px"><a href="tensor.transpose.html"><tt>transpose</tt></a><span>   (tensor)</span></td>
            <td>conjugate of a tensor  Input T - @tensor  Output T - @tensor</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.transpose.html"><tt>transpose</tt></a><span>   (vector3d)</span></td>
            <td>transpose vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.TSP.html"><tt>TSP</tt></a><span>   (vector3d)</span></td>
            <td>traveling salesman problem on the 2 dimensional unit-sphere</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>U<a name="20"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="uiimport.html"><tt>uiimport</tt></a></td>
            <td>overload standard MATLAB uiimport</td>
            <tr></tr>
            <td width="250px"><a href="ODF.uminus.html"><tt>uminus</tt></a><span>   (ODF)</span></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.uminus.html"><tt>uminus</tt></a><span>   (PoleFigure)</span></td>
            <td>implements -pf</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.uminus.html"><tt>uminus</tt></a><span>   (quaternion)</span></td>
            <td>overload unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="rotation.uminus.html"><tt>uminus</tt></a><span>   (rotation)</span></td>
            <td>implements -rotation</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.uminus.html"><tt>uminus</tt></a><span>   (vector3d)</span></td>
            <td>overloads unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="uniformODF.html"><tt>uniformODF</tt></a></td>
            <td>get crystal and specimen symmetry</td>
            <tr></tr>
            <td width="250px"><a href="unimodalODF.html"><tt>unimodalODF</tt></a></td>
            <td>define a unimodal ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.union.html"><tt>union</tt></a><span>   (PoleFigure)</span></td>
            <td>crytsallographic direction to one</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.union.html"><tt>union</tt></a><span>   (symmetry)</span></td>
            <td>returns the union of two symmetry groups</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.unique.html"><tt>unique</tt></a><span>   (PoleFigure)</span></td>
            <td>remove dublicated points in a polefigure</td>
            <tr></tr>
            <td width="250px"><a href="Miller.unique.html"><tt>unique</tt></a><span>   (Miller)</span></td>
            <td>disjoint list of Miller indices</td>
            <tr></tr>
            <td width="250px"><a href="orientation.unique.html"><tt>unique</tt></a><span>   (orientation)</span></td>
            <td>disjoint list of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.unique.html"><tt>unique</tt></a><span>   (quaternion)</span></td>
            <td>disjoint list of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.unique.html"><tt>unique</tt></a><span>   (rotation)</span></td>
            <td>disjoint list of rotations</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.unique.html"><tt>unique</tt></a><span>   (vector3d)</span></td>
            <td>disjoint list of vectors</td>
            <tr></tr>
            <td width="250px"><a href="UpDown.html"><tt>UpDown</tt></a></td>
            <td></td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>V<a name="21"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="vdisp.html"><tt>vdisp</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="vec2cell.html"><tt>vec2cell</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="vec42quat.html"><tt>vec42quat</tt></a></td>
            <td>returns a quaternion q with q u_1 = v1 and q u2 = v2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.velocity.html"><tt>velocity</tt></a><span>   (tensor)</span></td>
            <td>computes the elastic wave velocity(km/s) from the elastic stiffness Cijkl tensor and density (g/cm3)  Input C   - elasticity
               stiffness tensor Cijkl (UNITS GPa) @tensor x   - list of propagation directions (@vector3d) rho - material density (UNITS
               g/cm3)  Output vp  - velocity of the p--wave (UNITS km/s) vs1 - velocity of the s1--wave (UNITS km/s) vs2 - velocity
               of the s2--wave (UNITS km/s) pp  - polarisation of the p--wave (particle movement, vibration direction) ps1 - polarisation
               of the s1--wave (particle movement, vibration direction) ps2 - polarisation of the s2--wave (particle movement, vibration
               direction)
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.vertcat.html"><tt>vertcat</tt></a><span>   (quaternion)</span></td>
            <td>implements [q1;q2;q3..]</td>
            <tr></tr>
            <td width="250px"><a href="tensor.vertcat.html"><tt>vertcat</tt></a><span>   (tensor)</span></td>
            <td>overloads [T1,T2,T3..]</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.vertcat.html"><tt>vertcat</tt></a><span>   (vector3d)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="tensor.Voigt.html"><tt>Voigt</tt></a><span>   (tensor)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="ODF.volume.html"><tt>volume</tt></a><span>   (ODF)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.volume.html"><tt>volume</tt></a><span>   (ODFComponent)</span></td>
            <td>get resolution</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.volume.html"><tt>volume</tt></a><span>   (uniformComponent)</span></td>
            <td>for large angles or specimen symmetry take the quadrature based algorithm</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.volume.html"><tt>volume</tt></a><span>   (unimodalComponent)</span></td>
            <td>for large angles or specimen symmetry take the quadrature based algorithm</td>
            <tr></tr>
            <td width="250px"><a href="orientation.volume.html"><tt>volume</tt></a><span>   (orientation)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.volume.html"><tt>volume</tt></a><span>   (orientationRegion)</span></td>
            <td>volume of an orientation region</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.volume.html"><tt>volume</tt></a><span>   (sphericalRegion)</span></td>
            <td>volume of a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="kernel.volume.html"><tt>volume</tt></a><span>   (kernel)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="tensor.volumeCompressibility.html"><tt>volumeCompressibility</tt></a><span>   (tensor)</span></td>
            <td>computes the volume compressibility of an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="vonMisesFisherKernel.html"><tt>vonMisesFisherKernel</tt></a></td>
            <td></td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>W<a name="22"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="white2blackColorMap.html"><tt>white2blackColorMap</tt></a></td>
            <td>gray   Linear gray-scale color map</td>
            <tr></tr>
            <td width="250px"><a href="WhiteJetColorMap.html"><tt>WhiteJetColorMap</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="Wigner3j.html"><tt>Wigner3j</tt></a></td>
            <td>Compute the Wigner 3j symbol using the Racah formula.   W = Wigner3j( J123, M123 )   J123 = [J1, J2, J3], with the condition:
               |Ji - Jj| &lt;= Jk &lt;= (Ji + Jj)    (i,j,k are permutations of 1,2,3) M123 = [M1, M2, M3], with the conditions: |Mi| &lt;= Ji 
                 (i = 1,2,3) M1 + M2 + M3 = 0 All Ji and Mi have to be half integers (correspondingly).  Reference:  Wigner 3j-Symbol
               entry of Eric Weinstein's Mathworld: http://mathworld.wolfram.com/Wigner3j-Symbol.html  Inspired by Wigner3j.m by David
               Terr, Raytheon, 6-17-04 (available at www.mathworks.com/matlabcentral/fileexchange).  By Kobi Kraus, Technion, 25-6-08.
            </td>
            <tr></tr>
            <td width="250px"><a href="Wigner3j_new.html"><tt>Wigner3j_new</tt></a></td>
            <td>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</td>
            <tr></tr>
            <td width="250px"><a href="Wigner3jPrecomputed.html"><tt>Wigner3jPrecomputed</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="wignerD.html"><tt>wignerD</tt></a></td>
            <td>Wiegner-D function</td>
            <tr></tr>
            <td width="250px"><a href="wignerD2.html"><tt>wignerD2</tt></a></td>
            <td>spherical harmonics of degree l</td>
            <tr></tr>
            <td width="250px"><a href="WignerD3.html"><tt>WignerD3</tt></a></td>
            <td>Wigner-D function  Syntax  Dl = WignerD(g,'degree',l) D  = WignerD(g,'bandwidth',l) D  = W  Input g - @quaternion
               / @rotation / @orientation / @symmetry  Options bandwidth - harmonic degree of series expansion degree    - number or
               array, single degree reshapes result kernel    - multiply wigner coefficients by kernel   Output Dl - $(2l+1) \times (2l+1)$
               D  - $(l(2*l--1)(2*l+1)/3) \times n$ where n is the number of rotations  See also sphericalY
            </td>
            <tr></tr>
            <td width="250px"><a href="wignerDOld.html"><tt>wignerDOld</tt></a></td>
            <td>Wiegner-D function</td>
            <tr></tr>
            <td width="250px"><a href="write_cell.html"><tt>write_cell</tt></a></td>
            <td>write cell string to text file</td>
            <tr></tr>
            <td width="250px"><a href="writedouble.html"><tt>writedouble</tt></a></td>
            <td>write to file</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>X<a name="23"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="xnum2str.html"><tt>xnum2str</tt></a></td>
            <td>convert number to string</td>
            <tr></tr>
            <td width="250px"><a href="xticklabel_rotate.html"><tt>xticklabel_rotate</tt></a></td>
            <td>hText = xticklabel_rotate(XTick,rot,XTickLabel,varargin)     Rotate XTickLabel</td>
            <tr></tr>
            <td width="250px"><a href="xvector.html"><tt>xvector</tt></a></td>
            <td>vector (1,0,0)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>Y<a name="24"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="tensor.YoungsModulus.html"><tt>YoungsModulus</tt></a><span>   (tensor)</span></td>
            <td>Young's modulus for an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="yvector.html"><tt>yvector</tt></a></td>
            <td>vector (0,1,0)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>Z<a name="25"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="PoleFigure.zeroRange.html"><tt>zeroRange</tt></a><span>   (PoleFigure)</span></td>
            <td>implements the zero range method</td>
            <tr></tr>
            <td width="250px"><a href="zip_mtex.html"><tt>zip_mtex</tt></a></td>
            <td>zip mtex for publishing (on website)</td>
            <tr></tr>
            <td width="250px"><a href="zvector.html"><tt>zvector</tt></a></td>
            <td>vector (0,0,1)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <p style="font-size:1px;"></p>
         <table class="footer" border="0" width="100%" cellpadding="0" cellspacing="0">
            <tr>
               <td valign="baseline" align="right">MTEX 4.1.beta1</td>
            </tr>
         </table>
      </div>
   </body>
</html>