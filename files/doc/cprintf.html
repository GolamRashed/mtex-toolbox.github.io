
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <title> (DocHelp Toolbox)
         
      </title>
      <!-- DOCNAME: DocHelp Toolbox -->
      <meta name="chunktype" content="refpage">
      <!-- CHUNKNAME: cprintf -->
      <!-- HEADSTUFF: cprintf -->
      <!-- HEADSTUFF -->
      <meta name="refentity" content="method:cprintf">
      <meta http-equiv="Content-Script-Type" content="text/javascript">
      <meta name="toctype" content="fcn">
      <link rel="stylesheet" href="up.css"><script language="JavaScript" src="docscripts.js"></script></head>
   <body><a name="top_of_page"></a><div class="navbar navbar-inverse navbar-fixed-top">
         <div class="navbar-inner">
            <div class="container"><a class="brand" href="/">MTEX Toolbox</a><ul class="nav">
                  <li><a href="/download.html">Downloads</a></li>
               </ul>
               <ul class="nav">
                  <li><a href="/documentation.html">Documentation</a></li>
               </ul>
               <ul class="nav">
                  <li><a href="/team.html">People</a></li>
               </ul>
               <ul class="nav">
                  <li><a href="/publications.html">Publications</a></li>
               </ul>
               <ul class="nav">
                  <li><a href="/support.html">Support</a></li>
               </ul>
            </div>
         </div>
      </div>
      <div class="container"><pre class="codeinput"><span class="comment">%CPRINTF	convert an array of any data type to a 2D character array</span>
<span class="comment">%</span>
<span class="comment">%		- converts an ND array of any MATLAB data type</span>
<span class="comment">%		  to a 2D character array</span>
<span class="comment">%		- the input may be a cell array formatted as a table with</span>
<span class="comment">%		  row/column labels and row/column separators</span>
<span class="comment">%		- any input can be formatted as a table using</span>
<span class="comment">%		  any combination of</span>
<span class="comment">%		  row/column labels and row/column separators</span>
<span class="comment">%		- the result may be written/appended to an ASCII file or</span>
<span class="comment">%		  inserted at a user marked position</span>
<span class="comment">%</span>
<span class="comment">%		  see also: sprintf, fprintf, printmat, cphelp, setpref</span>
<span class="comment">%</span>
<span class="comment">%SYNTAX</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%		[T,TC,AC,P] = CPRINTF(A,OPT1,...,OPTn)</span>
<span class="comment">%				converts A</span>
<span class="comment">%		 P          = CPRINTF</span>
<span class="comment">%				returns  the engine parameters</span>
<span class="comment">%		              CPRINTF</span>
<span class="comment">%				displays the help</span>
<span class="comment">%</span>
<span class="comment">%INPUT</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">% A	:	an ND array of</span>
<span class="comment">%  		- real and/or complex full   numeric data</span>
<span class="comment">%  		- real and/or complex sparse numeric data</span>
<span class="comment">%  		- logical data</span>
<span class="comment">%  		- char strings</span>
<span class="comment">%		- structures</span>
<span class="comment">%  		- other objects</span>
<span class="comment">%  		an ND cell array of any combination of the above</span>
<span class="comment">%</span>
<span class="comment">% OPTION	argument	description		default</span>
<span class="comment">% ----------------------------------------------------------------</span>
<span class="comment">%		SC		a single CHAR</span>
<span class="comment">%		CS		a CHAR string</span>
<span class="comment">%		FS		a format spec</span>
<span class="comment">% ----------------------------------------------------------------</span>
<span class="comment">% CELL				data type</span>
<span class="comment">% ----------------------------------------------------------------</span>
<span class="comment">%    -c	:	FS		character string	'%s'</span>
<span class="comment">%    -n	:	FS		numeric real		'%g'</span>
<span class="comment">%   -cr	:	FS		numeric complex real	'%g'</span>
<span class="comment">%   -ci	:	FS		numeric complex imag	'%+gi'</span>
<span class="comment">%   -cd	:	FS		numeric complex delim	' '</span>
<span class="comment">%    -s	:	FS		numeric sparse indices	'(%g %g)'</span>
<span class="comment">%    -f	:	FS		false			'F'</span>
<span class="comment">%    -t	:	FS		true			'T'</span>
<span class="comment">%    -E	:	FS		empty CELL		'E(class)'</span>
<span class="comment">%    -I	:	FS		&#65533;Inf			'&#65533;INF'</span>
<span class="comment">%    -N	:	FS		NaN			'NAN'</span>
<span class="comment">%   -hs	:	T|F		convert to single hex	[F]</span>
<span class="comment">%   -hd	:	T|F		convert to double hex	[F]</span>
<span class="comment">%  -nex	:	T|F		no char CELL expansion	[F]</span>
<span class="comment">%    -O	:	FS		other objects		[built-in]</span>
<span class="comment">%   -Or	:	T|F		other objects raw mode	[built-in]</span>
<span class="comment">%    -C	:	FS		text surrounding CELLs	'%s'</span>
<span class="comment">%   -la	:	T|F		cell content alignment	[F]</span>
<span class="comment">%  -cla	:	T|F		complex alignment	[F]</span>
<span class="comment">%				F = right align</span>
<span class="comment">%				T = left  align</span>
<span class="comment">%</span>
<span class="comment">% ROW				content</span>
<span class="comment">% ----------------------------------------------------------------</span>
<span class="comment">%    -L	:	CS		leading   row text	''</span>
<span class="comment">%    -T	:	CS		trailing  row text	''</span>
<span class="comment">%    -d	:	SC		separator between CELLs	' '</span>
<span class="comment">%   -dt	:	SC		separator table columns	' '</span>
<span class="comment">%   -nd	:	T|F		show ND page indices	[F]</span>
<span class="comment">%</span>
<span class="comment">% TABLE				content / processing</span>
<span class="comment">% ----------------------------------------------------------------</span>
<span class="comment">%   -Ct	:	FS		text surrounding body	'%s'</span>
<span class="comment">%				but not label CELLs</span>
<span class="comment">%   -nc	:	FS		numeric real col	'%g'</span>
<span class="comment">%   -nr	:	FS		numeric real row</span>
<span class="comment">%   -Lh	:	{tn}		table  name		{' '}</span>
<span class="comment">%   -Lc	:	{c1...cn}	column labels</span>
<span class="comment">%   -Lr	:	{r1...rn}	row    labels</span>
<span class="comment">%  -Lcs	:	SC		column separator	''</span>
<span class="comment">%  -Lrs	:	SC		row    separator	''</span>
<span class="comment">%   -it	:	T|F		input is a       table	[F]</span>
<span class="comment">%   -mt	:	T|F		convert input to table	[F]</span>
<span class="comment">%   -ic	:	T|F		column width		[F]</span>
<span class="comment">%				F = max of all  cols</span>
<span class="comment">%				T = max of each col</span>
<span class="comment">%</span>
<span class="comment">% OUTPUT FILES</span>
<span class="comment">% ----------------------------------------------------------------</span>
<span class="comment">%   -fa	:	name		append to output file	[]</span>
<span class="comment">%   -fc	:	name		create    output file	[]</span>
<span class="comment">%   -fi	:	name		input  file		[]</span>
<span class="comment">%   -fm	:	marker		insert result at marker	[]</span>
<span class="comment">%				in file [-fin]</span>
<span class="comment">%   -fr	:	{t1,r1,...}	replace token tx with	[]</span>
<span class="comment">%				value rx</span>
<span class="comment">%</span>
<span class="comment">% PROCESSING</span>
<span class="comment">% ----------------------------------------------------------------</span>
<span class="comment">%    -p	:	T|F		do NOT use preferences	[F]</span>
<span class="comment">%  -opt	:	struct		use struct.option	[]</span>
<span class="comment">%  -ini	:	name		read options from file	[]</span>
<span class="comment">%  -sav	:	name		save options to   file	[]</span>
<span class="comment">%  -tab	:	n		use n SPACES/TAB	[8]</span>
<span class="comment">% -ntab	:	T|F		keep TABs in CELLs	[F]</span>
<span class="comment">%    -q	:	n		do not display result	[F]</span>
<span class="comment">%   -so	:	T|F		collect all output in	[F]</span>
<span class="comment">%				a structure</span>
<span class="comment">%   -db	:	T|F		show processing stages	[F]</span>
<span class="comment">%				and timing</span>
<span class="comment">%</span>
<span class="comment">%OUTPUT</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">% T	:	char array with same number of rows and</span>
<span class="comment">%		[-d] separated columns as A</span>
<span class="comment">% TC	:	cell array of T</span>
<span class="comment">% AC	:	cell array of A (useful if A is print as a table)</span>
<span class="comment">% P	:	structure with engine parameters</span>
<span class="comment">%</span>
<span class="comment">%NOTE</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%		- FS a format spec</span>
<span class="comment">%		     - a valid SPRINTF/FPRINTF format string</span>
<span class="comment">%		     - a function or function handle returning a</span>
<span class="comment">%		       character string, eg,</span>
<span class="comment">%		       by default, options -E uses the functions</span>
<span class="comment">%		       @(x) sprintf('E(%s)',class(x))</span>
<span class="comment">%		- by default, other data types are decoded according</span>
<span class="comment">%		       to their class (see CPHELP)</span>
<span class="comment">%		- by default, CELLs of Mx1 or ND character strings</span>
<span class="comment">%		  are expanded unless the [-nex] option is used</span>
<span class="comment">%		- all [-Lx] options take a cell of any data type</span>
<span class="comment">%		- all [-Lx/-Lxx] options override</span>
<span class="comment">%		  preset [-it] or default [-mt] table entries</span>
<span class="comment">%		- all [-Lx] label(s) will be repeated or cut</span>
<span class="comment">%		  automatically to fit the table size</span>
<span class="comment">%		- TC/AC may be used as input into several</span>
<span class="comment">%		  spreadsheet applications, eg, xlswrite</span>
<span class="comment">%		- at startup, CPRINTF will look for default options set by</span>
<span class="comment">%			setpref('cprintf','opt',{OPT1,...,OPTn});</span>
<span class="comment">%		     - runtime options will overwrite preferences</span>
<span class="comment">%		     - preferences are preserved between ML sessions</span>
<span class="comment">%		- if NO output argument is used, CPRINTF displays</span>
<span class="comment">%		  the result even if with a trailing &lt;;&gt;</span>
<span class="comment">%</span>
<span class="comment">%EXAMPLE</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%	m=reshape(1:3*5,[3,5]);</span>
<span class="comment">% %	print M including their binary representation</span>
<span class="comment">%	cprintf(m,'-n',@(x) sprintf('%d=%s',x,dec2bin(x,4)),'-d','| ')</span>
<span class="comment">% 		 1=0001|  4=0100|  7=0111| 10=1010| 13=1101</span>
<span class="comment">% 		 2=0010|  5=0101|  8=1000| 11=1011| 14=1110</span>
<span class="comment">% 		 3=0011|  6=0110|  9=1001| 12=1100| 15=1111</span>
<span class="comment">%</span>
<span class="comment">% %	print M as a table with default labels/separators</span>
<span class="comment">%	cprintf(m,'-n',@(x) sprintf('%d=%s',x,dec2bin(x,4)),'-mt',1)</span>
<span class="comment">% 		  |       1       2       3       4       5</span>
<span class="comment">% 		-------------------------------------------</span>
<span class="comment">% 		1 |  1=0001  4=0100  7=0111 10=1010 13=1101</span>
<span class="comment">% 		2 |  2=0010  5=0101  8=1000 11=1011 14=1110</span>
<span class="comment">% 		3 |  3=0011  6=0110  9=1001 12=1100 15=1111</span>

<span class="comment">% created:</span>
<span class="comment">%	us	12-Jun-2006 us@neurol.unizh.ch</span>
<span class="comment">% modified:</span>
<span class="comment">%	us	11-Jun-2009 08:58:55</span>
<span class="comment">%</span>
<span class="comment">% localid:	us@USZ|ws-nos-36362|x86|Windows XP|7.8.0.347.R2009a</span>
<span class="comment">%</span>
<span class="comment">% Copyright (c) 2009, urs (us) schwarz</span>
<span class="comment">% All rights reserved.</span>
<span class="comment">%</span>
<span class="comment">% Redistribution and use in source and binary forms, with or without</span>
<span class="comment">% modification, are permitted provided that the following conditions are</span>
<span class="comment">% met:</span>
<span class="comment">%</span>
<span class="comment">%     * Redistributions of source code must retain the above copyright</span>
<span class="comment">%       notice, this list of conditions and the following disclaimer.</span>
<span class="comment">%     * Redistributions in binary form must reproduce the above copyright</span>
<span class="comment">%       notice, this list of conditions and the following disclaimer in</span>
<span class="comment">%       the documentation and/or other materials provided with the distribution</span>
<span class="comment">%</span>
<span class="comment">% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span>
<span class="comment">% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="comment">% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="comment">% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="comment">% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="comment">% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="comment">% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="comment">% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="comment">% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="comment">% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="comment">% POSSIBILITY OF SUCH DAMAGE.</span>




<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	varargout=cprintf(varargin)

<span class="comment">% common parameters</span>
		magic=<span class="string">'CPRINTF'</span>;
		pver=<span class="string">'11-Jun-2009 08:58:55'</span>;

<span class="comment">% option table</span>
		F=false;
		<span class="comment">%femp=@(x) sprintf('E(%s)',class(x));</span>
    femp=@(x) <span class="string">''</span>;
		finf=@(x) upper(sprintf(<span class="string">'%+g'</span>,x));		<span class="comment">% sign!</span>
		foth=@CPRINTF_other;

		opt={
<span class="comment">%		opt	{default	isset}	% description</span>
<span class="comment">%		----------------------------------------------------------------</span>
<span class="comment">% cell</span>
		<span class="string">'-c'</span>	{<span class="string">'%s'</span>		F}	<span class="comment">% character	string</span>
		<span class="string">'-n'</span>	{<span class="string">'%g'</span>		F}	<span class="comment">% numeric	real</span>
		<span class="string">'-cr'</span>	{<span class="string">'%g'</span>		F}	<span class="comment">% numeric	complex real</span>
		<span class="string">'-ci'</span>	{<span class="string">'%+gi'</span>		F}	<span class="comment">% numeric	complex imag</span>
		<span class="string">'-cd'</span>	{<span class="string">' '</span>		F}	<span class="comment">% numeric	delimiter r/c</span>
		<span class="string">'-s'</span>	{<span class="string">'(%g %g)'</span>	F}	<span class="comment">% numeric	sparse</span>
		<span class="string">'-f'</span>	{<span class="string">'F'</span>		F}	<span class="comment">% logical	false</span>
		<span class="string">'-t'</span>	{<span class="string">'T'</span>		F}	<span class="comment">% logical	true</span>
		<span class="string">'-E'</span>	{femp		F}	<span class="comment">% empty		cell</span>
		<span class="string">'-I'</span>	{finf		F}	<span class="comment">% numeric	inf</span>
		<span class="string">'-N'</span>	{<span class="string">'NAN'</span>		F}	<span class="comment">% numeric	nan</span>
		<span class="string">'-hs'</span>	{F		F}	<span class="comment">% numeric	single hex</span>
		<span class="string">'-hd'</span>	{F		F}	<span class="comment">% numeric	double hex</span>
		<span class="string">'-nex'</span>	{F		F}	<span class="comment">% no expansion	ND char CELLs</span>
		<span class="string">'-O'</span>	{foth		F}	<span class="comment">% other</span>
		<span class="string">'-Or'</span>	{F		F}	<span class="comment">% other		raw</span>
		<span class="string">'-C'</span>	{<span class="string">''</span>		F}	<span class="comment">% surrounding	text</span>
		<span class="string">'-la'</span>	{F		F}	<span class="comment">% alignment	left</span>
		<span class="string">'-cla'</span>	{F		F}	<span class="comment">% alignment	left complex</span>
<span class="comment">% col</span>
		<span class="string">'-hdr'</span>	{{<span class="string">''</span>}		F}	<span class="comment">% text		header</span>
		<span class="string">'-ftr'</span>	{{<span class="string">''</span>}		F}	<span class="comment">% text		footer</span>
<span class="comment">% row</span>
		<span class="string">'-L'</span>	{<span class="string">''</span>		F}	<span class="comment">% text		leading</span>
		<span class="string">'-T'</span>	{<span class="string">''</span>		F}	<span class="comment">% text		trailing</span>
		<span class="string">'-d'</span>	{<span class="string">' '</span>		F}	<span class="comment">% separator</span>
		<span class="string">'-dt'</span>	{<span class="string">' '</span>		F}	<span class="comment">% separator	table only</span>
		<span class="string">'-nd'</span>	{<span class="string">''</span>		F}	<span class="comment">% ND array	page indices</span>
<span class="comment">% table</span>
		<span class="string">'-Ct'</span>	{<span class="string">''</span>		F}	<span class="comment">% surrounding	text table only</span>
		<span class="string">'-nc'</span>	{<span class="string">''</span>		F}	<span class="comment">% numeric	col labels</span>
		<span class="string">'-nr'</span>	{<span class="string">''</span>		F}	<span class="comment">% numeric	row labels</span>
		<span class="string">'-Lh'</span>	{{<span class="string">''</span>}		F}	<span class="comment">% name</span>
		<span class="string">'-Lc'</span>	{{<span class="string">''</span>}		F}	<span class="comment">% col		group names</span>
		<span class="string">'-Lr'</span>	{{<span class="string">''</span>}		F}	<span class="comment">% row		group names</span>
		<span class="string">'-Lcs'</span>	{<span class="string">'-'</span>		F}	<span class="comment">% col		separator</span>
		<span class="string">'-Lrs'</span>	{<span class="string">'|'</span>		F}	<span class="comment">% row		separator</span>
		<span class="string">'-it'</span>	{F		F}	<span class="comment">% assume	table</span>
		<span class="string">'-mt'</span>	{F		F}	<span class="comment">% force		table</span>
		<span class="string">'-ic'</span>	{F		F}	<span class="comment">% individual	size</span>
<span class="comment">% file</span>
		<span class="string">'-fa'</span>	{<span class="string">''</span>		F}	<span class="comment">% append	output file</span>
		<span class="string">'-fc'</span>	{<span class="string">''</span>		F}	<span class="comment">% create	output file</span>
		<span class="string">'-fi'</span>	{<span class="string">''</span>		F}	<span class="comment">% input		file template</span>
		<span class="string">'-fm'</span>	{<span class="string">''</span>		F}	<span class="comment">% input		file marker</span>
		<span class="string">'-fr'</span>	{{<span class="string">''</span>}		F}	<span class="comment">% replace	tokens</span>
<span class="comment">% processing</span>
		<span class="string">'-p'</span>	{F		F}	<span class="comment">% remove	preferences</span>
		<span class="string">'-opt'</span>	{F		F}	<span class="comment">% use		option structure</span>
		<span class="string">'-ini'</span>	{<span class="string">''</span>		F}	<span class="comment">% load		option file</span>
		<span class="string">'-sav'</span>	{<span class="string">''</span>		F}	<span class="comment">% save		option file</span>
		<span class="string">'-tab'</span>	{8		F}	<span class="comment">% \t		SPACES</span>
		<span class="string">'-ntab'</span>	{F		F}	<span class="comment">% TAB		no replacement</span>
		<span class="string">'-q'</span>	{F		F}	<span class="comment">% result	not displayed</span>
		<span class="string">'-so'</span>	{F		F}	<span class="comment">% output	struct</span>
		<span class="string">'-db'</span>	{F		F}	<span class="comment">% debug</span>
<span class="comment">% HIDDEN/ENGINE</span>
		<span class="string">'-ce'</span>	{F		F}	<span class="comment">% character	strings (empty)</span>
		<span class="string">'-ninf'</span>	{F		F}	<span class="comment">% marker	has NAN/INF</span>
		};

<span class="comment">% - sort option table</span>
		[opt(:,1),pix]=sort(opt(:,1));
		opt(:,2)=opt(pix,2);
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">% check IO</span>
	<span class="keyword">if</span>	~nargin
	<span class="keyword">if</span>	nargout
		[ctbl,par]=CPRINTF_setengine(magic,pver,opt,varargin{:});
		varargout{1}=par;
		varargout{2}=opt;			<span class="comment">% internal use only</span>
	<span class="keyword">else</span>
		help(mfilename);
	<span class="keyword">end</span>
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%		main engine</span>
<span class="comment">%-------------------------------------------------------------------------------</span>

		[ctbl,par]=CPRINTF_setengine(magic,pver,opt,varargin{:});

		par.disp(<span class="string">'CP| --------- :'</span>);
		t0=clock;
	<span class="keyword">if</span>	~par.hasopt.ntab
		ctbl(par.in)=strrep(ctbl(par.in),par.tabc,par.tabs);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hasopt.c				&amp;&amp;<span class="keyword">...</span>
		all(par.in)
		[ctbl,par]=CPRINTF_char(par,ctbl);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~all(par.in)
		[ctbl,par]=CPRINTF_cell2ascii(par,ctbl);
	<span class="keyword">else</span>
	<span class="keyword">if</span>	par.hasopt.C
		ix=find(par.in(:));
		[ctbl,par]=CPRINTF_cell(par,ctbl,ix,par.opt.C);
	<span class="keyword">elseif</span>	par.hasopt.Ct
		tf=false(par.pr,par.pc);
		tf(par.tbody(1):par.tbody(2),par.tbody(3):par.tbody(4))=true;
		ix=find(tf(:));
		[ctbl,par]=CPRINTF_cell(par,ctbl,ix,par.opt.Ct);
	<span class="keyword">else</span>
		par.in=false;
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		ctbl=reshape(ctbl,par.pr,par.pc);
		rtbl=ctbl;
		[ctbl,par]=CPRINTF_ascii2string(par,ctbl);
		par.disp(<span class="string">'CP| --------- : %10s = %19.6f sec'</span>,<span class="string">'done'</span>,etime(clock,t0));
		par.disp(CPRINTF_repmat(<span class="string">'-'</span>,[1,52]));

		[ctbl,par]=CPRINTF_write(par,ctbl);

	<span class="keyword">if</span>	nargout &gt;= 1
		varargout{1}=ctbl;
	<span class="keyword">if</span>	nargout &gt;= 2
		varargout{2}=rtbl;
	<span class="keyword">if</span>	nargout &gt;= 3
		varargout{3}=par.carg;
	<span class="keyword">if</span>	nargout &gt;= 4
		varargout{4}=par;
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hasopt.so
		varargout{1}=par;
		varargout{1}.text=ctbl;
		varargout{1}.cell=rtbl;
	<span class="keyword">end</span>
	<span class="keyword">elseif</span>	~par.hasopt.q
		disp(ctbl);
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%		low level utility functions</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	CPRINTF_disp(varargin)
		disp(sprintf(varargin{:}));
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	CPRINTF_nodisp(varargin)
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	m=CPRINTF_macro

<span class="comment">% keep workspace of function handles small</span>

		m={
<span class="comment">%		macro		function handle</span>
<span class="comment">%		-------------------------------------------------------------------</span>
		<span class="string">'getpar'</span>	@(varargin)	CPRINTF_parse_option(0,varargin{:})
		<span class="string">'setpar'</span>	@(varargin)	CPRINTF_struct2opt(0,varargin{:})
		<span class="string">'ini'</span>		@(varargin)	CPRINTF_ini2opt(0,varargin{:})
		<span class="string">'write'</span>		@(varargin)	CPRINTF_ascii2file(varargin{:})
		<span class="string">'other'</span>		@CPRINTF_other
		<span class="string">'comb'</span>		@(varargin)	CPRINTF_comb([varargin{:}])
		<span class="string">'disp'</span>		@CPRINTF_disp
		<span class="string">'s2f'</span>		@str2func
		};
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	res=CPRINTF_str2fh(str)

<span class="comment">% keep fh.workspace{:} small</span>
		res=@(x) sprintf(str,class(x));
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	res=CPRINTF_fh2fh(par,fh)

		th=functions(fh);
	<span class="keyword">if</span>	~isempty(th.file)			&amp;&amp;<span class="keyword">...</span>
		~strcmp(th.file,which(mfilename))
<span class="comment">% ********** THE WORST CASE SCENARIO! **********</span>
<span class="comment">% - this construct needed due to an error in PUBLISH	!</span>
<span class="comment">% - fh from an INI file contains a bad file pointer</span>

  		fn=th.function;
		ix=find(fn==<span class="string">'@'</span>,1,<span class="string">'first'</span>);
		fn=fn(ix:end);
		res=par.s2f(fn);

	<span class="keyword">else</span>
		res=fh;
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	res=CPRINTF_opt2cell(opt)

		on=cellfun(@(x) [<span class="string">'-'</span>,x],fieldnames(opt),<span class="string">'uni'</span>,false);
		res=reshape([on,struct2cell(opt)].',[],1).';
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[opt,oflg]=CPRINTF_struct2opt(par,varargin)

	<span class="keyword">if</span>	~nargout
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

		opt=[];
		oflg=[];
	<span class="keyword">if</span>	nargin &lt; 2				||<span class="keyword">...</span>
		~isstruct(varargin{1})
	<span class="keyword">if</span>	~nargout
		clear <span class="string">opt</span>;
	<span class="keyword">end</span>
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

	<span class="keyword">if</span>	~isstruct(par)
		par=cprintf;
	<span class="keyword">end</span>
		par.opt=par.otbl;
		copt=CPRINTF_opt2cell(varargin{1});
		[opt,oflg]=CPRINTF_parse_option(opt,copt{:});
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	res=CPRINTF_repmat(tok,siz)

<span class="comment">% faster repmat replacement</span>
	<span class="keyword">if</span>	ischar(tok)
		res={tok};
		res=res(ones(siz));
		res=cat(2,res{:});
	<span class="keyword">else</span>
		res=repmat(tok,siz);
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_nd2d(par,ctbl)

<span class="comment">% force 2D array</span>
		par.ndc=ndims(ctbl);
		par.nsc=size(ctbl);
	<span class="keyword">if</span>	par.ndc &gt; 2
		ctbl=permute(ctbl,[1,3:numel(par.nsc),2]);
		ctbl=reshape(ctbl,[],par.nsc(2));
	<span class="keyword">end</span>
		[par.pr,par.pc]=size(ctbl);
		par.nnc=numel(ctbl);
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_ndchar(par,ctbl)

		id=[];
		ic=0;

<span class="comment">% spares numeric are never ND</span>
	<span class="keyword">if</span>	par.type.sparse
		par.opt.nd=true(size(ctbl,1),1);
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

<span class="comment">% show ND page indices</span>
<span class="comment">% - text</span>
	<span class="keyword">if</span>	par.hasopt.nd				&amp;&amp;<span class="keyword">...</span>
		ischar(par.opt.nd)
		hasnd=true;
		larg=par.opt.nd;
		ichr=cellfun(@ischar,ctbl);
	<span class="keyword">if</span>	any(ichr)
		ctbl=CPRINTF_cell(par,ctbl,find(ichr),@(x) sprintf(<span class="string">'''%s'''</span>,x));
	<span class="keyword">end</span>
		ic=~cellfun(@isreal,ctbl);
	<span class="keyword">if</span>	any(ic(:))
		ttbl=cell(par.pr+prod(par.nsc(3:end)),par.pc+max(sum(ic,2)));
		ix=[false;CPRINTF_repmat(true,[par.nsc(1),1])];
		ix=[CPRINTF_repmat(ix,[prod(par.nsc(3:end)),1]);false(par.nsc(1),1)];
		iv=find(ix);
	<span class="keyword">for</span>	i=1:numel(iv)
		cx=iv(i);
	<span class="keyword">for</span>	j=1:par.pc
		ttbl(cx,2*j-1)={real(ctbl{i,j})};
	<span class="keyword">if</span>	ic(i,j)
		ttbl(cx,2*j)={imag(ctbl{i,j})};
	<span class="keyword">else</span>
		ttbl(cx,2*j)={0};
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		ctbl=ttbl;
		iv=ix;
		par.nsc(2)=size(ctbl,2);

	<span class="keyword">else</span>
		ix=[false;CPRINTF_repmat(true,[par.nsc(1),1])];
		ix=CPRINTF_repmat(ix,[prod(par.nsc(3:end)),1]);
		iv=true(size(ctbl,1),1);
	<span class="keyword">end</span>
		ic=max(sum(ic,2));

<span class="comment">% - logical</span>
	<span class="keyword">else</span>
		hasnd=false;
		larg=<span class="string">''</span>;
		ix=[false;CPRINTF_repmat(true,[par.nsc(1),1])];
		ix=CPRINTF_repmat(ix,[prod(par.nsc(3:end)),1]);
		iv=true(size(ctbl,1),1);
	<span class="keyword">end</span>

	<span class="keyword">if</span>	 par.hasopt.nd				&amp;&amp;<span class="keyword">...</span>
		(par.ndc &gt; 2				||<span class="keyword">...</span>
		 hasnd)

	<span class="keyword">if</span>	strcmp(par.class,<span class="string">'struct'</span>)
		[res,id]=CPRINTF_comb(size(par.arg),true);
	<span class="keyword">else</span>
		[res,id]=CPRINTF_comb(par.nsc,true);
	<span class="keyword">end</span>

		ac=CPRINTF_repmat({<span class="string">''</span>},[size(ix,1),par.pc+ic]);
		ac(ix,:)=ctbl(iv,:);
		ctbl=ac;
		iv=true(size(ix,1),1);
		ix=find(~ix);
		ix=ix(1:numel(res));
		ctbl(ix,1)=res;
		[par.pr,par.pc]=size(ctbl);
		par.carg=ctbl;
	<span class="keyword">end</span>

<span class="comment">% mixed char/other classes</span>
<span class="comment">% - ND char arrays</span>
		par.in=cellfun(@ischar,ctbl);
	<span class="keyword">if</span>	any(par.in(:))
		cd=cellfun(@ndims,ctbl);
		cs=cellfun(@(x) size(x,1),ctbl);
		cs(~par.in)=1;
		ix=find(cd&gt;2&amp;par.in);
<span class="comment">%   force 2D</span>
	<span class="keyword">if</span>	~isempty(ix)
	<span class="keyword">for</span>	i=1:numel(ix)
		ttbl=ctbl{ix(i)};
		ttbl=CPRINTF_nd2d(par,ttbl);
		ctbl{ix(i)}=ttbl;
	<span class="keyword">end</span>
		cs=cellfun(@(x) size(x,1),ctbl);
	<span class="keyword">end</span>

	<span class="keyword">if</span>	any(cs(:)&gt;1)
	<span class="keyword">if</span>	par.hasopt.nex
		par.nmod=3;
		ix=find(cs(:)&gt;1);
		[ctbl,par]=CPRINTF_cell(par,ctbl,ix,par.opt.O);
	<span class="keyword">else</span>
		cx=[1;1+cumsum(max(cs,[],2))];
		ac=CPRINTF_repmat({<span class="string">''</span>},[cx(end)-1,par.pc]);
	<span class="keyword">for</span>	i=1:numel(cx)-1
		aoff=cx(i);
	<span class="keyword">for</span>	j=1:size(cs,2)
		ct=ctbl{i,j};
	<span class="keyword">if</span>	ischar(ct)
	<span class="keyword">for</span>	k=1:cs(i,j)
		ac(aoff+k-1,j)={ct(k,:)};
	<span class="keyword">end</span>
	<span class="keyword">else</span>
		ac(aoff,j)=ctbl(i,j);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		ctbl=ac;
		[par.pr,par.pc]=size(ctbl);
		par.carg=ctbl;
		iv=false;
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% set page indices</span>
	<span class="keyword">if</span>	par.hasopt.nd				&amp;&amp;<span class="keyword">...</span>
		~isempty(id)

	<span class="keyword">if</span>	~iv
		par.opt.nd=~strncmp(ctbl(:,1),id,numel(id));
	<span class="keyword">else</span>
		par.opt.nd=~strncmp(ctbl(:,1),id,numel(id)) &amp; iv;
	<span class="keyword">end</span>
		ctbl(~par.opt.nd)=strrep(ctbl(~par.opt.nd),id,larg);

	<span class="keyword">if</span>	hasnd
		par.opt.n=@(x) sprintf(<span class="string">'''%s'''</span>,num2hex(x));
		par.hasopt.Or=true;
		icarg=iscell(par.arg);
		par.pc=par.pc+1;
		ctbl(:,end+1)={<span class="string">''</span>};

		lsh=<span class="string">')'</span>;
		rsh=<span class="string">''</span>;
	<span class="keyword">if</span>	ischar(par.arg)
		lsh=<span class="string">')=[...'</span>;
		rsh=<span class="string">'];'</span>;
	<span class="keyword">elseif</span>	par.isnumeric				&amp;&amp;<span class="keyword">...</span>
		icarg
		lsh=<span class="string">')=num2cell(reshape(hex2num({'</span>;
		rsh=sprintf(<span class="string">'}),[%d,%d]));'</span>,par.nsc(1:2));
	<span class="keyword">elseif</span>	par.isnumeric
		lsh=<span class="string">')=reshape(hex2num({'</span>;
		rsh=sprintf(<span class="string">'}),[%d,%d]);'</span>,par.nsc(1:2));
	<span class="keyword">elseif</span>	icarg
		lsh=<span class="string">')={'</span>;
		rsh=<span class="string">'};'</span>;
	<span class="keyword">end</span>

	<span class="keyword">if</span>	ic
		ix=par.pr-prod(par.nsc(3:end))+1:par.pr;
	<span class="keyword">for</span>	i=1:numel(ix)
		ctbl{ix(i),1}=sprintf(<span class="string">'%s = arrayfun(@(x,y) complex(x,y),%s(%d,1:2:end),%s(%d,2:2:end),''uni'',true);'</span>,res{i},larg,i,larg,i);
	<span class="keyword">end</span>
		ctbl(ix)=strrep(ctbl(ix),id,larg);
	<span class="keyword">else</span>
	<span class="keyword">end</span>
		ix=find(~par.opt.nd);
		ix=ix(ix&gt;0);
		ix=ix(1:prod(par.nsc(3:end)));
		ctbl(ix)=regexprep(ctbl(ix),<span class="string">')'</span>,lsh);
		ix=ix+prod(par.nsc(3:end))+0;
		ctbl(ix,end)={rsh};
	<span class="keyword">end</span>

	<span class="keyword">else</span>
		par.opt.nd=true(par.pr,1);
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[res,id]=CPRINTF_comb(siz,varargin)

	<span class="keyword">if</span>	nargin == 1
		noff=0;
	<span class="keyword">else</span>
		noff=2;
	<span class="keyword">end</span>

		narg=numel(siz);
		n=narg-noff;
	<span class="keyword">if</span>	n
		arg=cell(n,1);
		x=cell(n,1);
	<span class="keyword">for</span>	i=1:n
		arg{i}=1:siz(i+noff);
	<span class="keyword">end</span>
	<span class="keyword">else</span>
		arg{1}=1;
	<span class="keyword">end</span>

	<span class="keyword">if</span>	n &gt; 1
		[x{1:n,1}]=ndgrid(arg{1:end});
		res=reshape(cat(n+1,x{:}),[],n);
	<span class="keyword">else</span>
		res=arg{:}.';
	<span class="keyword">end</span>

<span class="comment">% create unique page marker</span>
	<span class="keyword">if</span>	nargin &gt; 1
		id=sprintf(<span class="string">'_$$##%s##$$_'</span>,num2hex(rand(1,10)).');
		fmt=sprintf(<span class="string">'(%d:%d,%d:%d'</span>,1,siz(1),1,siz(2));
		fmt=[id,fmt,CPRINTF_repmat(<span class="string">',%d'</span>,[1,n]),<span class="string">')\n'</span>];
		res=sprintf(fmt,res.');
		res=strread(res,<span class="string">'%s'</span>,<span class="string">'delimiter'</span>,<span class="string">'\n'</span>);
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_setengine(magic,pver,opt,varargin)

<span class="comment">% common engine parameters</span>
		par.magic=magic;
		par.(<span class="string">'ver'</span>)=pver;
		par.MLver=version;
		par.section_10=<span class="string">'---------- INPUT   ------------'</span>;
		par.arg={};
		par.class=<span class="string">''</span>;
		par.isnumeric=false;
		par.section_20=<span class="string">'---------- OPTIONS ------------'</span>;
		par.otbl=opt;
		par.hasotbl=false(size(opt));
		par.opt=opt;
		par.hasopt=[];
		par.islog={};
		par.section_30=<span class="string">'---------- ENGINE  ------------'</span>;
		par.fpar={};
		par.ctbl={};
		par.ndc=0;
		par.nsc=0;
		par.nnc=0;
		par.pr=0;
		par.pc=0;
		par.in=[];
		par.sconv=0;
		par.type=whos(<span class="string">'magic'</span>);		<span class="comment">% assign WHOS table</span>
		par.istbl=false;
		par.hastbl=[false,false];	<span class="comment">% row/col table labels/separators</span>
		par.tlabel=[];
		par.tbody=[];
		par.sepr=[];
		par.sepc=[];
		par.fmt=[];
		par.fmts=[];
		par.dels=[];			<span class="comment">% spaces: between numbers</span>
		par.delst=[];
		par.tabc=sprintf(<span class="string">'\t'</span>);
		par.tabs=<span class="string">''</span>;
		par.nmod=1;			<span class="comment">% number: 1 = real</span>
		par.section_31=<span class="string">'---------- macros   -----------'</span>;
<span class="comment">% assign macros created in a small function to save memory</span>
		mac=CPRINTF_macro;
	<span class="keyword">for</span>	i=1:size(mac,1)
		par.(mac{i,1})=mac{i,2};
	<span class="keyword">end</span>
		par.section_40=<span class="string">'---------- OUTPUT  ------------'</span>;
		par.text=<span class="string">''</span>;
		par.cell={};
		par.carg={};


<span class="comment">% get input/options</span>
		[ctbl,par]=CPRINTF_parse(par,varargin{:});
<span class="comment">% set table labels/separators</span>
		[ctbl,par]=CPRINTF_setlabel(par,ctbl);

<span class="comment">% update parameters</span>
	<span class="keyword">if</span>	~par.istbl
		par.fpar(end-1:end,:)=[];
		par.fpar{end,4}=[];
	<span class="keyword">else</span>
		par.fpar{5,4}=[1,par.pr,3,par.pc];
		par.fpar{6,4}=[3,par.pr,3,par.pc];
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~isempty(ctbl)
		par.in=cellfun(@ischar,ctbl);
		ctbl=ctbl(:);
		par.in=par.in(:);
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	par=CPRINTF_getfpar(par,mode)

<span class="comment">% formatting spec</span>
		T=true;
		F=false;
		par.fpar={
<span class="comment">%		--------------------------------------------</span>
<span class="comment">% - 1 empty</span>
		T	{par.opt.E,par.opt.E}	<span class="string">'empty'</span>	,<span class="keyword">...</span>
			[]					,<span class="keyword">...</span>
			@isempty				,<span class="keyword">...</span>
			@CPRINTF_empty
<span class="comment">% - 2 nan/inf</span>
		F	{par.opt.N,par.opt.I}	<span class="string">'naninf'</span>	,<span class="keyword">...</span>
			[]					,<span class="keyword">...</span>
			@isnumeric				,<span class="keyword">...</span>
			@CPRINTF_naninf
<span class="comment">% - 3 logical</span>
		T	{par.opt.f,par.opt.t}	<span class="string">'logical'</span>	,<span class="keyword">...</span>
			[]					,<span class="keyword">...</span>
			@islogical				,<span class="keyword">...</span>
			@CPRINTF_logical
<span class="comment">% - 4 numeric</span>
		T	{par.opt.n,par.opt.n}	<span class="string">'numeric'</span>	,<span class="keyword">...</span>
			par.tlabel				,<span class="keyword">...</span>
			@isnumeric				,<span class="keyword">...</span>
			@CPRINTF_number
<span class="comment">% - 5 numeric</span>
		T	{par.opt.nr,par.opt.nr}	<span class="string">'row label'</span>	,<span class="keyword">...</span>
			par.tbody				,<span class="keyword">...</span>
			@isnumeric				,<span class="keyword">...</span>
			@CPRINTF_number
<span class="comment">% - 6 numeric</span>
		T	{par.opt.nc,par.opt.nc}	<span class="string">'col label'</span>	,<span class="keyword">...</span>
			par.tbody				,<span class="keyword">...</span>
			@isnumeric				,<span class="keyword">...</span>
			@CPRINTF_number
		};

	<span class="keyword">switch</span>	mode
	<span class="keyword">case</span>	1
		par.fpar(end-1:end,:)=[];
		par.fpar{end,4}=[];
	<span class="keyword">case</span>	2
	<span class="keyword">otherwise</span>
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_parse(par,varargin)

	<span class="keyword">if</span>	nargin &gt; 1
		arg=varargin{1};
	<span class="keyword">else</span>
<span class="comment">% create complete engine parameter structure</span>
		par=CPRINTF_parse_option(par,varargin{:});
		par=CPRINTF_getfpar(par,2);
		ctbl=[];
		<span class="keyword">return</span>;
	<span class="keyword">end</span>
		par.istbl=false;
		par.arg=arg;
		ctbl=arg;

		[par.pr,par.pc]=size(ctbl);
		par.class=class(ctbl);
		par.isnumeric=isnumeric(ctbl);
		par.type=whos(<span class="string">'ctbl'</span>);

		par=CPRINTF_parse_option(par,varargin{:});

<span class="comment">% input class</span>
<span class="comment">% - ND struct</span>
	<span class="keyword">if</span>	isstruct(ctbl)
		cs=size(ctbl);
		sf=fieldnames(ctbl);
		nf=numel(sf);
<span class="comment">% - anomalies!</span>
	<span class="keyword">if</span>	~any(cs)
		ctbl=[sf,CPRINTF_repmat({<span class="string">'[?]'</span>},[nf,1])];
	<span class="keyword">elseif</span>	~nf
		ctbl=repmat({<span class="string">'?'</span>,<span class="string">'[?]'</span>},cs);
	<span class="keyword">else</span>
		ns=ones(size(cs));
		ns(1:2)=[nf,2];
		ttbl=cell(cs.*ns);
		ic=1:cs(1);
		ix=1:nf*cs(1);
		nx=numel(ix);
		ni=numel(ttbl)/nx;
	<span class="keyword">for</span>	i=1:ni;
		cx=(i-1)*nx+ix;
	<span class="keyword">if</span>	bitand(i,1)
		ttbl(cx)=CPRINTF_repmat(sf,[cs(1),1]);
	<span class="keyword">else</span>
		ttbl(cx)=struct2cell(ctbl(ic));
		ic=ic+numel(ic);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		ctbl=ttbl;
	<span class="keyword">end</span>
	<span class="keyword">end</span>

	<span class="keyword">if</span>	isempty(ctbl)
<span class="comment">% D		error('%s&gt; invalid/empty input',par.magic);</span>
	<span class="keyword">if</span>	iscell(ctbl)
		ctbl=CPRINTF_cell(par,{{}},1,par.opt.E);
	<span class="keyword">else</span>
		ctbl={ctbl};
	<span class="keyword">end</span>
	<span class="keyword">end</span>

	<span class="keyword">if</span>	~iscell(ctbl)
		ttbl=ctbl;
	<span class="keyword">switch</span>	par.class
<span class="comment">% - char array</span>
	<span class="keyword">case</span>	<span class="string">'char'</span>
		[ttbl,par]=CPRINTF_nd2d(par,ttbl);
		ctbl=cell(par.pr,1);
	<span class="keyword">for</span>	i=1:par.pr
		ctbl(i,1)={ttbl(i,:)};
	<span class="keyword">end</span>
	<span class="keyword">otherwise</span>
<span class="comment">% - numeric</span>
	<span class="keyword">if</span>	par.type.sparse
<span class="comment">%   2D sparse</span>
		[cr,cc,cv]=find(ctbl);
	<span class="keyword">if</span>	isempty(cr)
		cv=0;
		[cr,cc]=size(ctbl);
	<span class="keyword">end</span>
		ttbl=[cr,cc,cv];
		[par.pr,par.pc]=size(ttbl);
	<span class="keyword">else</span>
		[ttbl,par]=CPRINTF_nd2d(par,ctbl);
	<span class="keyword">end</span>

		ctbl=cell(par.pr,par.pc);
		par.nnc=numel(ctbl);

<span class="comment">%   numeric/logical</span>
	<span class="keyword">if</span>	isnumeric(ttbl)				||<span class="keyword">...</span>
		islogical(ttbl)
	<span class="keyword">for</span>	i=1:par.nnc
		ctbl(i)={ttbl(i)};
	<span class="keyword">end</span>
	<span class="keyword">else</span>
		ctbl={ttbl};
	<span class="keyword">end</span>

	<span class="keyword">end</span>	<span class="comment">% par.class</span>
	<span class="keyword">else</span>
<span class="comment">% - cell</span>
		par.isnumeric=cellfun(@isnumeric,ctbl);
		par.isnumeric=all(par.isnumeric(:));
		[ctbl,par]=CPRINTF_nd2d(par,ctbl);
<span class="comment">%   convert sparse to full</span>
		par.in=cellfun(@issparse,ctbl);
	<span class="keyword">if</span>	any(par.in(:))
		ctbl(par.in)=cellfun(@(x) full(x),ctbl(par.in),<span class="string">'uni'</span>,false);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		[par.pr,par.pc]=size(ctbl);
		par.carg=ctbl;

		[ctbl,par]=CPRINTF_ndchar(par,ctbl);

		par.tlabel=-[1,2,1,2];
		par.tbody=[1,par.pr,1,par.pc];
		par=CPRINTF_getfpar(par,2);
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[par,opt]=CPRINTF_parse_option(par,varargin)

<span class="comment">% simple (fast) option parser</span>
<span class="comment">% - default</span>
	<span class="keyword">if</span>	~isstruct(par)
<span class="comment">%   internal use only!</span>
		par=cprintf;
		voff=1;
	<span class="keyword">else</span>
		voff=2;
	<span class="keyword">end</span>

		par.opt=par.otbl;
		op=par.opt(:,1);
		hasop=false(size(op));
		par.islog=cat(1,par.opt{:,2});
		par.islog=cellfun(@islogical,par.islog(:,1));
		par.islog=strrep(op(par.islog),<span class="string">'-'</span>,<span class="string">''</span>);

		narg=numel(varargin);
	<span class="keyword">if</span>	narg

<span class="comment">% - display options</span>
		par.hasopt.db=false;
		par.hasopt.q=false;
		ix=strcmp(varargin,<span class="string">'-db'</span>);
	<span class="keyword">if</span>	any(ix(:))
		ix=find(ix,1,<span class="string">'last'</span>);
	<span class="keyword">if</span>	ix &lt; narg
		par.hasopt.db=~isempty(varargin{ix+1});
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		ix=strcmp(varargin,<span class="string">'-q'</span>);
	<span class="keyword">if</span>	any(ix(:))
		ix=find(ix,1,<span class="string">'last'</span>);
	<span class="keyword">if</span>	ix &lt; narg
		par.hasopt.q=~isempty(varargin{ix+1});
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% - use preferences</span>
		popt={};
	<span class="keyword">if</span>	~strcmp(varargin,<span class="string">'-p'</span>)
		pref=getpref(lower(par.magic));
	<span class="keyword">if</span>	isfield(pref,<span class="string">'opt'</span>)
		popt=pref.opt;
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% - use ini file</span>
		iopt={};
		ix=strcmp(varargin,<span class="string">'-ini'</span>);
	<span class="keyword">if</span>	any(ix)

		ix=find(ix,1,<span class="string">'last'</span>)+1;
		fini=varargin{ix};
		fout=<span class="string">''</span>;
		ix=strcmp(varargin,<span class="string">'-sav'</span>);
	<span class="keyword">if</span>	any(ix)
		ix=find(ix,1,<span class="string">'last'</span>)+1;
		fout=varargin{ix};
	<span class="keyword">end</span>
		[iopt,par]=CPRINTF_ini2opt(par,fini,fout);
		iopt=CPRINTF_opt2cell(iopt);

	<span class="keyword">end</span>

<span class="comment">% - use option struct</span>
		oopt={};
		ix=strcmp(varargin,<span class="string">'-opt'</span>);
	<span class="keyword">if</span>	any(ix)
		ix=find(ix,1,<span class="string">'last'</span>)+1;
	<span class="keyword">if</span>	isstruct(varargin{ix})
		oopt=varargin{ix};
		oopt=CPRINTF_opt2cell(oopt);
		varargin{ix}=true;
	<span class="keyword">end</span>

	<span class="keyword">end</span>

<span class="comment">% - command line</span>
		arg=[popt,iopt,oopt,varargin(voff:end)];
		narg=numel(arg);
	<span class="keyword">if</span>	~isempty(arg)
		ix=find(<span class="keyword">...</span>
			cellfun(@ischar,arg)		&amp;<span class="keyword">...</span>
			cellfun(@(x) size(x,1)==1,arg));
		[ia,iv]=ismember(op,arg(ix));
		ia=find(ia);
		iv=iv(iv&gt;0);
	<span class="keyword">for</span>	i=1:numel(ix(iv))
		cix=ix(iv(i));
	<span class="keyword">if</span>	cix+1 &gt; narg
		error(<span class="string">'%s&gt; [%s] argument missing'</span>,par.magic,arg{cix});
	<span class="keyword">end</span>
		cia=ia(i);
		hasop(cia)=~isempty(arg{cix+1});
		par.opt{cia,2}(1)=arg(cix+1);
		par.opt{cia,2}{2}=hasop(cia);
	<span class="keyword">end</span>
	<span class="keyword">end</span>

	<span class="keyword">end</span>	<span class="comment">% has arguments</span>

<span class="comment">% - finalize option structure</span>
		par.opt(:,1)=strrep(par.opt(:,1),<span class="string">'-'</span>,<span class="string">''</span>);
<span class="comment">%   MACRO call</span>
	<span class="keyword">if</span>	voff == 1
		par.opt=par.opt(hasop,:);
	<span class="keyword">end</span>
		par.opt=par.opt.';
		par.opt=struct(par.opt{:});
		par.hasopt=par.opt(2);
		par.opt=par.opt(1);
		par.hasotbl=hasop;

	<span class="keyword">if</span>	~isempty(varargin)			&amp;&amp;<span class="keyword">...</span>
		voff == 2
		par=CPRINTF_parse_chkoption(par);
	<span class="keyword">end</span>

<span class="comment">%   MACRO call</span>
	<span class="keyword">if</span>	nargout					&amp;&amp;<span class="keyword">...</span>
		voff == 1
		opt=par.hasopt;
		par=par.opt;
	<span class="keyword">elseif</span>	voff == 1
		clear <span class="string">par</span>;
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	par=CPRINTF_parse_chkoption(par)

<span class="comment">% check/adjust	options</span>
<span class="comment">% - set		hasopt.xx of logical options xx</span>
	<span class="keyword">for</span>	clog=par.islog(:).'
		tlog=clog{1};
	<span class="keyword">if</span>	par.hasopt.(tlog)
		tval=par.opt.(tlog);
		par.hasopt.(tlog)=false;
	<span class="keyword">if</span>	~isempty(tval)				&amp;&amp;<span class="keyword">...</span>
		 isscalar(tval)				&amp;&amp;<span class="keyword">...</span>
		(ischar(tval)				||<span class="keyword">...</span>
		 isnumeric(tval)			||<span class="keyword">...</span>
		 islogical(tval))
		par.hasopt.(tlog)=tval~=0;
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% - R2009b</span>
		ws=warning(<span class="string">'off'</span>,<span class="string">'all'</span>);
	<span class="keyword">try</span>
		v=par.s2f(<span class="string">'@(x) x'</span>);			<span class="comment">% WARNING only</span>
		v(10);					<span class="comment">% ERROR   to catch</span>
	<span class="keyword">catch</span>	<span class="comment">%#ok</span>
		par.s2f=@eval;
	<span class="keyword">end</span>
		warning(ws);

<span class="comment">% - [-db]	debug	: check once only!</span>
	<span class="keyword">if</span>	par.hasopt.db
		par.disp=@CPRINTF_disp;
	<span class="keyword">else</span>
		par.disp=@CPRINTF_nodisp;
	<span class="keyword">end</span>
<span class="comment">% - [-tab]	TAB - SPACES replacement</span>
		spc=<span class="string">' '</span>;
	<span class="keyword">if</span>	~isnumeric(par.opt.tab)
		error(<span class="string">'%s&gt; [-tab] must be numeric'</span>,par.magic);
	<span class="keyword">end</span>
		par.tabs=spc(ones([1,par.opt.tab]));
<span class="comment">% - [-d]	must be CHAR</span>
	<span class="keyword">if</span>	~ischar(par.opt.d)
		error(<span class="string">'%s&gt; [-d] cell separator must be characters'</span>,par.magic);
	<span class="keyword">end</span>
		par.opt.d=sprintf(par.opt.d);
		par.dels=numel(par.opt.d);
<span class="comment">% - [-dt]	must be CHAR</span>
	<span class="keyword">if</span>	~ischar(par.opt.dt)
		error(<span class="string">'%s&gt; [-dt] table cell separator must be characters'</span>,par.magic);
	<span class="keyword">end</span>
		par.opt.dt=sprintf(par.opt.dt);
		par.delst=numel(par.opt.dt);
<span class="comment">% - [-cd]	must be CHAR</span>
	<span class="keyword">if</span>	par.hasopt.cd
	<span class="keyword">if</span>	~ischar(par.opt.cd)
		error(<span class="string">'%s&gt; [-cd] real/complex separator must be characters'</span>,par.magic);
	<span class="keyword">end</span>
		par.opt.cd=sprintf(par.opt.cd);
		par.opt.cd=strrep(par.opt.cd,par.tabc,par.tabs);
	<span class="keyword">end</span>
<span class="comment">% - [-Lcs]	must be CHAR</span>
	<span class="keyword">if</span>	par.hasopt.Lcs				&amp;&amp;<span class="keyword">...</span>
		~ischar(par.opt.Lcs)
		error(<span class="string">'%s&gt; [-Lcs] col separator must be a character string'</span>,par.magic)
	<span class="keyword">end</span>
<span class="comment">% - [-Lrs]	must be CHAR</span>
	<span class="keyword">if</span>	par.hasopt.Lrs				&amp;&amp;<span class="keyword">...</span>
		~ischar(par.opt.Lrs)
		error(<span class="string">'%s&gt; [-Lrs] col separator must be a character string'</span>,par.magic)
	<span class="keyword">end</span>
<span class="comment">% - [-L]	must be CHAR</span>
	<span class="keyword">if</span>	par.hasopt.L				&amp;&amp;<span class="keyword">...</span>
		~ischar(par.opt.L)
		error(<span class="string">'%s&gt; [-L] leading row text must be a character string'</span>,par.magic)
	<span class="keyword">end</span>
<span class="comment">% - [-T]	must be CHAR</span>
	<span class="keyword">if</span>	par.hasopt.T				&amp;&amp;<span class="keyword">...</span>
		~ischar(par.opt.T)
		error(<span class="string">'%s&gt; [-T] trailing row text must be a character string'</span>,par.magic)
	<span class="keyword">end</span>
<span class="comment">% - [-E]	must be function handle created in CPRINTF</span>
<span class="comment">%		must return a char string</span>
	<span class="keyword">if</span>	par.hasopt.E
	<span class="keyword">if</span>	ischar(par.opt.E)
		par.opt.E=CPRINTF_str2fh(par.opt.E);
	<span class="keyword">elseif</span>	isa(par.opt.E,<span class="string">'function_handle'</span>)
		par.opt.E=CPRINTF_fh2fh(par,par.opt.E);
	<span class="keyword">end</span>

		par.opt.E({[]});

	<span class="keyword">end</span>
<span class="comment">% - [-O]	must be function handle created in CPRINTF</span>
<span class="comment">%		must return a char string</span>
	<span class="keyword">if</span>	par.hasopt.O
	<span class="keyword">if</span>	ischar(par.opt.O)
		par.opt.O=CPRINTF_str2fh(par.opt.O);
	<span class="keyword">elseif</span>	isa(par.opt.O,<span class="string">'function_handle'</span>)
		par.opt.O=CPRINTF_fh2fh(par,par.opt.O);
	<span class="keyword">end</span>

		par.opt.O(cell(1,1));

	<span class="keyword">end</span>
<span class="comment">% - [-fm]</span>
	<span class="keyword">if</span>	par.hasopt.fm
	<span class="keyword">if</span>	~ischar(par.opt.fm)
		error(<span class="string">'%s&gt; [-fm] file insertion marker must be a character string'</span>,par.magic);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	size(par.opt.fm,1) &gt; 1
		error(<span class="string">'%s&gt; [-fm] file insertion marker must have size 1xN'</span>,par.magic);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="comment">% - [-fr]	cell of 1xN CHAR strings</span>
	<span class="keyword">if</span>	par.hasopt.fr
	<span class="keyword">if</span>	~iscell(par.opt.fr)
		error(<span class="string">'%s&gt; [-fr] token replacement strings must be in a cell'</span>,par.magic);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	any(~cellfun(@ischar,par.opt.fr))
		error(<span class="string">'%s&gt; [-fr] all tokens/replacement strings must be character strings'</span>,par.magic);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	any(cellfun(@(x) size(x,1),par.opt.fr)&gt;1)
		error(<span class="string">'%s&gt; [-fr] all token replacement strings must have size 1xN'</span>,par.magic);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="comment">% - sparse	[-Lc]	must be adjusted</span>
	<span class="keyword">if</span>	par.type.sparse
	<span class="keyword">if</span>	par.hasopt.Lc
		par.opt.Lc=[par.opt.Lc,par.opt.Lc{end}];
	<span class="keyword">end</span>
<span class="comment">%		[-it]	cannot be a table</span>
	<span class="keyword">if</span>	par.hasopt.it
		error(<span class="string">'%s&gt; [-it] sparse input cannot be a table: use [-mt]'</span>,par.magic);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="comment">% - hex		array/table body: all numeric format specs</span>
	<span class="keyword">if</span>	par.hasopt.hs
		fhx=@(x) sprintf(<span class="string">'%s'</span>,num2hex(single(x)));
		par.opt.n=fhx;
		par.opt.cr=fhx;
		par.opt.ci=fhx;
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hasopt.hd
		fhx=@(x) sprintf(<span class="string">'%s'</span>,num2hex(double(x)));
		par.opt.n=fhx;
		par.opt.cr=fhx;
		par.opt.ci=fhx;
	<span class="keyword">end</span>
<span class="comment">% - [-mt]	overrides [-it]</span>
	<span class="keyword">if</span>	par.hasopt.mt
		par.hasopt.it=false;
	<span class="keyword">end</span>
<span class="comment">% - [-it]	cannot use [-nd]</span>
	<span class="keyword">if</span>	par.hasopt.it
		par.hasopt.nd=false;
	<span class="keyword">end</span>
<span class="comment">% - [-N] / [-I]	has any of the option</span>
		par.hasopt.ninf=par.hasopt.N|par.hasopt.I;
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_setlabel(par,ctbl)


<span class="comment">% anatomy of a table</span>
<span class="comment">%{
</span><span class="comment">	.hastbl(1) = ROWS:	1 = +label	2 = +separator
</span><span class="comment">	.hastbl(2) = COLS:	1 = +label	2 = +separator
</span><span class="comment">
</span><span class="comment">								.hastbl(1)
</span><span class="comment">		nan	|	a	b	c		1
</span><span class="comment">		=========================================	2
</span><span class="comment">		aa	|	e	e	e
</span><span class="comment">		bb	|	e	e	e
</span><span class="comment">
</span><span class="comment">	.hastbl(2)
</span><span class="comment">		1
</span><span class="comment">			2
</span><span class="comment">
</span><span class="comment">	.tlabel(1:2)	ROW ix
</span><span class="comment">	.tlabel(3:4)	COL ix
</span><span class="comment">
</span><span class="comment">	.tbody(1)		-	-	-	ROW_1 ROW_n
</span><span class="comment">
</span><span class="comment">	.tbody(2)		|			COL_1 COL_n
</span><span class="comment">				|
</span><span class="comment">
</span><span class="comment">%}
</span>
<span class="comment">% set row/col labels/separators</span>
	<span class="keyword">if</span>	par.hasopt.it
		[ctbl,par]=CPRINTF_istable(par,ctbl);
	<span class="keyword">elseif</span>	par.hasopt.mt
		[ctbl,par]=CPRINTF_chklabel(par,ctbl,<span class="string">'col'</span>,1,<span class="string">'Lc'</span>,<span class="string">'-'</span>);
		[ctbl,par]=CPRINTF_chklabel(par,ctbl,<span class="string">'row'</span>,2,<span class="string">'Lr'</span>,<span class="string">'|'</span>);
		[ctbl,par]=CPRINTF_forcetable(par,ctbl);
	<span class="keyword">elseif</span>	~par.hasopt.Lc				&amp;&amp;<span class="keyword">...</span>
		~par.hasopt.Lr
		<span class="keyword">return</span>;
	<span class="keyword">end</span>
		[ctbl,par]=CPRINTF_formatlabel(par,ctbl);

		par.hastbl=[0,0];
		[ctbl,par]=CPRINTF_chklabel(par,ctbl,<span class="string">'col'</span>,1,<span class="string">'Lc'</span>,<span class="string">'-'</span>);
		[ctbl,par]=CPRINTF_chklabel(par,ctbl,<span class="string">'row'</span>,2,<span class="string">'Lr'</span>,<span class="string">'|'</span>);

	<span class="keyword">if</span>	par.hasopt.it
		par.hastbl=[2,2];
		ctbl(1,:)=par.opt.Lc(:).';
		ctbl(:,1)=par.opt.Lr(:);
	<span class="keyword">if</span>	par.hasopt.Lrs
		ctbl(:,2)=CPRINTF_repmat({par.opt.Lrs},[par.pr,1]);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hasopt.Lcs
		ctbl(2,:)=CPRINTF_repmat({par.opt.Lcs},[1,par.pc]);
	<span class="keyword">end</span>
	<span class="keyword">end</span>

		[ctbl,par]=CPRINTF_settable(par,ctbl);
		par.ctbl=ctbl;
		[par.pr,par.pc]=size(ctbl);
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_chklabel(par,ctbl,ltype,ix,lmod,lsep)

<span class="comment">% set field names</span>
		lmods=[lmod,<span class="string">'s'</span>];
		sepm=[<span class="string">'sep'</span>,lmod(2)];
		cnum=[<span class="string">'p'</span>,lmod(2)];
		mfmt=par.opt.([<span class="string">'n'</span>,lmod(2)]);

	<span class="keyword">if</span>	par.hasopt.(lmod)

	<span class="keyword">if</span>	~iscell(par.opt.(lmod))
		error(<span class="string">'%s&gt; %s label(s) must be in a CELL'</span>,par.magic,ltype);
	<span class="keyword">else</span>
	<span class="keyword">if</span>	ix == 2
		cnum=par.(cnum)-numel(find(~par.opt.nd));
	<span class="keyword">else</span>
		cnum=par.(cnum);
	<span class="keyword">end</span>

	<span class="keyword">if</span>	numel(par.opt.(lmod)) ~= cnum
	<span class="keyword">if</span>	par.hasopt.db
		warning(<span class="string">'CPRINTF:chklabel'</span>,<span class="string">'%s&gt; #%s label(s) does not match table size: %d ~= %d'</span>,<span class="keyword">...</span>
			par.magic,ltype,numel(par.opt.(lmod)),cnum);
		disp(sprintf(<span class="string">'%s&gt; #%s label(s) does not match table size: %d ~= %d'</span>,<span class="keyword">...</span>
			par.magic,ltype,numel(par.opt.(lmod)),cnum));
	<span class="keyword">end</span>
		nop=numel(par.opt.(lmod));
	<span class="keyword">if</span>	nop &lt; cnum
		nop=ceil(cnum./nop);
		par.opt.(lmod)=CPRINTF_repmat(par.opt.(lmod),[1,nop]);
	<span class="keyword">end</span>
		par.opt.(lmod)=par.opt.(lmod)(1:cnum);
	<span class="keyword">end</span>
		par.hastbl(ix)=1;
		par.opt.(lmod)=par.opt.(lmod)(:);
	<span class="keyword">if</span>	par.hasopt.(lmods)
		par.(sepm)={par.opt.(lmods)};
		par.hastbl(ix)=2;
	<span class="keyword">else</span>
		par.(sepm)={lsep};
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~par.hasopt.(lmods)
<span class="comment">% D		par.hasopt.(lmods)=true;</span>
		par.opt.(lmods)=par.(sepm){1};
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% print numeric labels</span>
	<span class="keyword">if</span>	~isempty(mfmt)
	<span class="keyword">if</span>	par.hasopt.(lmod)
		t=par.opt.(lmod);
		in=find(cellfun(@isnumeric,t)		&amp;<span class="keyword">...</span>
			cellfun(@isscalar,t));
		ie=	cellfun(@isnan,t(in))		|<span class="keyword">...</span>
			cellfun(@isinf,t(in))		|<span class="keyword">...</span>
			cellfun(@isempty,t(in))		|<span class="keyword">...</span>
			cellfun(@islogical,t(in));
		in=in(~ie);
		t=CPRINTF_cell(par,t,in,mfmt);
		par.opt.(lmod)=t;
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% separators must be 1 CHAR</span>
	<span class="keyword">if</span>	par.hasopt.(lmods)
	<span class="keyword">if</span>	~ischar(par.opt.(lmods))		||<span class="keyword">...</span>
		numel(par.opt.(lmods)) &gt; 1
		error(<span class="string">'%s&gt; %s separator must be a single character'</span>,par.magic,ltype);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_istable(par,ctbl)

<span class="comment">% -it :	is a table</span>

	<span class="keyword">if</span>	par.pr &lt; 3				||<span class="keyword">...</span>
		par.pc &lt; 3
		error(<span class="string">'%s&gt; table size to small (min size: 3x3): [%d/%d]'</span>,par.magic,par.pr,par.pc);
	<span class="keyword">end</span>

	<span class="keyword">if</span>	~par.hasopt.Lr
		par.hasopt.Lr=true;			<span class="comment">% set T!</span>
		par.opt.Lr=ctbl(:,1);
	<span class="keyword">else</span>
		par.opt.Lr=[ctbl(1:2,1);par.opt.Lr(:)];
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~par.hasopt.Lc				<span class="comment">% set T!</span>
		par.hasopt.Lc=true;
		par.opt.Lc=ctbl(1,:);
	<span class="keyword">else</span>
		par.opt.Lc=[ctbl(1,1:2),par.opt.Lc(:).'];
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~par.hasopt.Lrs				<span class="comment">% do NOT set T!</span>
		par.opt.Lrs=ctbl{par.pr,2};
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~par.hasopt.Lcs				<span class="comment">% do NOT set T!</span>
		par.opt.Lcs=ctbl{2,par.pc};
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_forcetable(par,ctbl)

<span class="comment">% -mt :	make a table</span>
<span class="comment">%	set all HASOPT T</span>

	<span class="keyword">if</span>	~par.hasopt.Lr
		par.hasopt.Lr=true;
		par.opt.Lr=CPRINTF_repmat({<span class="string">''</span>},[par.pr,1]);
		par.opt.Lr(par.opt.nd)=num2cell(1:numel(find(par.opt.nd)));
	<span class="keyword">else</span>
		lr=CPRINTF_repmat({<span class="string">''</span>},[par.pr,1]);
		lr(par.opt.nd)=par.opt.Lr;
		par.opt.Lr=lr;
	<span class="keyword">end</span>
		par.opt.Lr(~par.opt.nd)={<span class="string">'page'</span>};
		par.opt.nd=true(size(par.opt.Lr));

	<span class="keyword">if</span>	~par.hasopt.Lc
		par.hasopt.Lc=true;
		par.opt.Lc=num2cell(1:par.pc);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~par.hasopt.Lrs
		par.hasopt.Lrs=true;
		par.opt.Lrs=<span class="string">'|'</span>;
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~par.hasopt.Lcs
		par.hasopt.Lcs=true;
		par.opt.Lcs=<span class="string">'-'</span>;
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_formatlabel(par,ctbl)

<span class="comment">% -nr	row label format</span>
	<span class="keyword">if</span>	~par.hasopt.nr
		par.hasopt.nr=true;
		mfmt=max([1,ceil(log10(par.pr))]);
		par.opt.nr=sprintf(<span class="string">'r:%%%d.%dd'</span>,mfmt,mfmt);
	<span class="keyword">end</span>

<span class="comment">% -nc	col label format</span>
	<span class="keyword">if</span>	~par.hasopt.nc
		par.hasopt.nc=true;
		mfmt=max([1,ceil(log10(par.pc))]);
		par.opt.nc=sprintf(<span class="string">'c:%%%d.%dd'</span>,mfmt,mfmt);
	<span class="keyword">end</span>

<span class="comment">% -Lh	table name</span>
	<span class="keyword">if</span>	par.hasopt.Lh
	<span class="keyword">if</span>	~iscell(par.opt.Lh)			||<span class="keyword">...</span>
		numel(par.opt.Lh) &gt; 1
		error(<span class="string">'%s&gt; [-Lh] table name must be a single CELL'</span>,par.magic);
	<span class="keyword">end</span>
		paro=par;
		paro.in=cellfun(@ischar,paro.opt.Lh);
	<span class="keyword">if</span>	~paro.in
		[paro.pr,paro.pc]=size(paro.opt.Lh);
		paro=CPRINTF_getfpar(paro,1);
		paro.hasopt.Ct=false;
		par.opt.Lh=CPRINTF_cell2ascii(paro,paro.opt.Lh);
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% update formatting engine</span>
		par=CPRINTF_getfpar(par,2);
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_settable(par,ctbl)

<span class="comment">% create a full table</span>
<span class="comment">%	indices:	tbody/tlabel</span>
<span class="comment">% col	1:2</span>
<span class="comment">% row	3:4</span>

	<span class="keyword">if</span>	par.hastbl(2) &amp;&amp; ~par.hastbl(1)
		par.opt.Lc=CPRINTF_repmat({<span class="string">'c'</span>},[1,par.pc]);
		par.sepc=CPRINTF_repmat({<span class="string">'c'</span>},[1,par.pc+2]);
	<span class="keyword">else</span>
		par.sepc=CPRINTF_repmat(par.sepc,[1,par.pc+2]);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hastbl(1) &amp;&amp; ~par.hastbl(2)
		par.opt.Lr=CPRINTF_repmat({<span class="string">'r'</span>},[par.pr,1]);
		par.sepr=CPRINTF_repmat({<span class="string">'r'</span>},size(par.opt.Lr));
	<span class="keyword">else</span>
		par.sepr=CPRINTF_repmat(par.sepr,size(par.opt.Lr));
	<span class="keyword">end</span>

	<span class="keyword">if</span>	~par.hasopt.it
		ctbl=[[{<span class="string">' '</span>,par.opt.Lrs},par.opt.Lc(:).';par.sepc(:).'];par.opt.Lr(:),par.sepr(:),ctbl];
	<span class="keyword">end</span>

		[pr,pc]=size(ctbl);

<span class="comment">% ROW</span>
	<span class="keyword">if</span>	par.hastbl(1) == 2
		par.tbody(1:2)=[3,pr];
		par.tlabel(1:2)=[-1,-2];
	<span class="keyword">elseif</span>	par.hastbl(1) == 1
		par.tbody(1:2)=[2,pr-1];
		par.tlabel(1:2)=[-1,-1];
		ctbl(2,:)=[];
	<span class="keyword">else</span>
		par.tbody(1:2)=[1,pr-2];
		par.tlabel(1:2)=[0,0];
		ctbl(1:2,:)=[];
	<span class="keyword">end</span>
<span class="comment">% COL</span>
	<span class="keyword">if</span>	par.hastbl(2) == 2
		par.tbody(3:4)=[3,pc];
		par.tlabel(3:4)=[-1,-2];
	<span class="keyword">elseif</span>	par.hastbl(2) == 1
		par.tbody(3:4)=[2,pc-1];
		par.tlabel(3:4)=[-1,-1];
		ctbl(:,2)=[];
	<span class="keyword">else</span>
		par.tbody(3:4)=[1,pc-2];
		par.tlabel(3:4)=[-1,0];
		ctbl(:,1:2)=[];
	<span class="keyword">end</span>
<span class="comment">% NAME</span>
	<span class="keyword">if</span>	par.hastbl(1)				&amp;&amp;<span class="keyword">...</span>
		par.hastbl(2)
	<span class="keyword">if</span>	par.hasopt.Lh
		ctbl(1,1)=par.opt.Lh;
	<span class="keyword">end</span>
	<span class="keyword">end</span>

	<span class="keyword">if</span>	sum(par.hastbl) == 4
		par.istbl=true;
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%		printing routines</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_cell2ascii(par,ctbl)

		par.disp(<span class="string">'CP| format    : %10s   %8d c'</span>,<span class="string">' '</span>,numel(ctbl)-sum(par.in));
		t0=clock;
<span class="comment">% save memory</span>
<span class="comment">% - data type</span>
<span class="comment">%   CHAR</span>
		ic=par.in;
	<span class="keyword">if</span>	par.hasopt.c
	<span class="keyword">if</span>	any(ic)
		[ctbl,par]=CPRINTF_char(par,ctbl);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="comment">%   SCALAR NUMERIC | LOGICAL</span>
		par.in=	 cellfun(@isempty,ctbl)		|<span class="keyword">...</span>
			 cellfun(@isscalar,ctbl);
		par.in=	 par.in				&amp;<span class="keyword">...</span>
			(cellfun(@islogical,ctbl)	|<span class="keyword">...</span>
			 cellfun(@isnumeric,ctbl));
<span class="comment">%   OTHER</span>
		ic=~(ic|par.in);
	<span class="keyword">if</span>	any(ic)
		par.nmod=3;
		[ctbl,par]=CPRINTF_cell(par,ctbl,find(ic),par.opt.O);
	<span class="keyword">end</span>

	<span class="keyword">if</span>	any(par.in)

	<span class="keyword">for</span>	i=1:size(par.fpar,1)
	<span class="keyword">if</span>	par.fpar{i,1}
		sin=sum(par.in);
	<span class="keyword">if</span>	sin
		par.sconv=0;
		t1=clock;
		par.disp(<span class="string">'CP| type      : %10s = %8d c'</span>,par.fpar{i,3},sin);
		fh=par.fpar{i,end};
		[ctbl,par]=fh(par,ctbl,par.fpar(i,:));
		par.disp(<span class="string">'CP| type      : %10s = -%7d c %8.6f sec'</span>,par.fpar{i,3},par.sconv,etime(clock,t1));
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>

	<span class="keyword">end</span>

<span class="comment">% note to programmers: this should NEVER happen...</span>
	<span class="keyword">if</span>	any(par.in)
		par.nmod=3;
 		[ctbl,par]=CPRINTF_cell(par,ctbl,find(par.in),par.opt.O);
	<span class="keyword">end</span>

	<span class="keyword">if</span>	par.hasopt.C
		ix=1:numel(ctbl);
		[ctbl,par]=CPRINTF_cell(par,ctbl,ix,par.opt.C);
		ctbl=strrep(ctbl,par.tabc,par.tabs);
	<span class="keyword">elseif</span>	par.hasopt.Ct
		tf=false(par.pr,par.pc);
		tf(par.tbody(1):par.tbody(2),par.tbody(3):par.tbody(4))=true;
		ix=find(tf(:));
		[ctbl,par]=CPRINTF_cell(par,ctbl,ix,par.opt.Ct);
		ctbl(ix)=strrep(ctbl(ix),par.tabc,par.tabs);
	<span class="keyword">end</span>

		par.disp(<span class="string">'CP| format    : %10s = %8d c %8.6f sec'</span>,<span class="string">'done'</span>,sum(par.in),etime(clock,t0));
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_ascii2string(par,ctbl)

		par.disp(<span class="string">'CP| print     : %10s   %8d c'</span>,<span class="string">' '</span>,numel(ctbl));
		t0=clock;

		[ctbl,par]=CPRINTF_format(par,ctbl);

<span class="comment">% - note: for larger T, this is MUCH faster than</span>
<span class="comment">%   sprintf(fmt,t{:});</span>

	<span class="keyword">for</span>	i=1:par.pr
		ctbl{i,1}=sprintf(par.fmt,ctbl{i,1:par.pc});
		ctbl(i,2:par.pc)={[]};
	<span class="keyword">end</span>

		par.disp(<span class="string">'CP| print     : %10s = %19.6f sec'</span>,<span class="string">'done'</span>,etime(clock,t0));

		ctbl=ctbl(:,1);
		ctbl=char(ctbl);

<span class="comment">% set rowcol separators</span>
		nc=size(ctbl,2);
		hastab=	any(strfind(par.opt.d,par.tabc)~=0)	||<span class="keyword">...</span>
			any(strfind(par.opt.dt,par.tabc)~=0);
	<span class="keyword">if</span>	par.hasopt.L
		coff=max([1,numel(par.opt.L)]);
	<span class="keyword">else</span>
		coff=1;
	<span class="keyword">end</span>

	<span class="keyword">if</span>	par.istbl
	<span class="keyword">if</span>	~hastab					&amp;&amp;<span class="keyword">...</span>
		par.hasopt.Lcs
	<span class="keyword">if</span>	numel(par.opt.Lcs) == 1
		mrk=par.opt.Lcs;
		ctbl(2,coff:coff+nc-1)=CPRINTF_repmat(mrk,[1,nc]);
	<span class="keyword">else</span>
		ctbl(2,coff:coff+numel(par.opt.Lcs)-1)=par.opt.Lcs;
		par.hasopt.Lcs=false;
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hastbl(1) == 2
	<span class="keyword">if</span>	~hastab					&amp;&amp;<span class="keyword">...</span>
		par.hasopt.Lcs
		ctbl(2,coff:coff+nc-1)=CPRINTF_repmat(par.opt.Lcs,[1,nc]);
	<span class="keyword">end</span>
	<span class="keyword">end</span>

<span class="comment">% add header/footer</span>
<span class="comment">% - undocumented</span>
	<span class="keyword">if</span>	par.hasopt.hdr
		hdr=cprintf(par.opt.hdr,<span class="string">'-mt'</span>,0,<span class="string">'-ic'</span>,1);
		ctbl=char([
			{hdr}
			{ctbl}
		]);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hasopt.ftr
		hdr=cprintf(par.opt.ftr,<span class="string">'-mt'</span>,0,<span class="string">'-ic'</span>,1);
		ctbl=char([
			{ctbl}
			{hdr}
		]);
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_format(par,ctbl)

<span class="comment">% create format spec for columns</span>
		mfmt=max(cellfun(@numel,ctbl),[],1);
		mfmt1=mfmt(1);
	<span class="keyword">if</span>	~par.hasopt.ic
	<span class="keyword">if</span>	par.istbl				||<span class="keyword">...</span>
		par.hastbl(2)
		mfmt(3:end)=max(mfmt(3:end));
	<span class="keyword">else</span>
		mfmt(1:end)=max(mfmt);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">if</span>	any(par.hastbl)
		mfmt(1)=mfmt1;
	<span class="keyword">end</span>
		par.fmts=mfmt;
		mfmt=CPRINTF_repmat(mfmt,[2,1]);
		mfmt=mfmt(:).';
	<span class="keyword">if</span>	par.hasopt.la				<span class="comment">% do NOT use .hasopt.la</span>
		mfmt=sprintf(<span class="string">'-%d.%d '</span>,mfmt);		<span class="comment">% left align cells</span>
	<span class="keyword">else</span>
		mfmt=sprintf(<span class="string">'%d.%d '</span>,mfmt);
	<span class="keyword">end</span>
		mfmt=regexp(mfmt,<span class="string">'\s'</span>,<span class="string">'split'</span>);
		mfmt(end)=[];

<span class="comment">% - set col delimiter</span>
	<span class="keyword">if</span>	par.istbl
		par.fmt=CPRINTF_repmat(<span class="string">'%XsY'</span>,[1,par.pc]);

	<span class="keyword">else</span>
		par.fmt=CPRINTF_repmat(<span class="string">'Y%Xs'</span>,[1,par.pc]);
	<span class="keyword">end</span>

		par.fmt=regexprep(par.fmt,<span class="string">'X'</span>,mfmt,<span class="string">'once'</span>);
	<span class="keyword">if</span>	par.hasopt.dt				&amp;&amp;<span class="keyword">...</span>
		par.hastbl(2)
	<span class="keyword">for</span>	i=1:2
		par.fmt=regexprep(par.fmt,<span class="string">'Y'</span>,par.opt.d,<span class="string">'once'</span>);
	<span class="keyword">end</span>
		par.fmt=regexprep(par.fmt,<span class="string">'Y'</span>,par.opt.dt);
	<span class="keyword">else</span>
		par.fmt=regexprep(par.fmt,<span class="string">'Y'</span>,par.opt.d);
	<span class="keyword">end</span>

<span class="comment">% - remove leading/trailing col delimiter</span>
		dels=par.dels;
	<span class="keyword">if</span>	par.hasopt.dt
		dels=par.delst;
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.istbl
		par.fmt=par.fmt(1:end-dels);
	<span class="keyword">else</span>
		par.fmt=par.fmt(dels+1:end);
	<span class="keyword">end</span>
		par.fmt=sprintf(<span class="string">'%s%s%s'</span>,par.opt.L,par.fmt,par.opt.T);

		[ctbl,par]=CPRINTF_formattable(par,ctbl);
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_formattable(par,ctbl)

	<span class="keyword">if</span>	par.hasopt.Lcs				&amp;&amp;<span class="keyword">...</span>
		par.hastbl(1) == 2
		ctbl(2,:)=arrayfun(@(x) CPRINTF_repmat(par.opt.Lcs,[1,x]),par.fmts,<span class="string">'uni'</span>,false);
	<span class="keyword">end</span>

<span class="comment">% - insert col separators if not user defined</span>
	<span class="keyword">if</span>	par.istbl				&amp;&amp;<span class="keyword">...</span>
		~par.hasopt.Lcs
		in=cellfun(@numel,ctbl(2,:));
		ix=in==1;
	<span class="keyword">if</span>	isempty(strfind(par.opt.d,par.tabc))
		dels=par.dels;
	<span class="keyword">else</span>
		dels=0;
	<span class="keyword">end</span>
		fmts=par.fmts+dels;
		fmts(1)=par.fmts(1);

	<span class="keyword">if</span>	any(ix)
		ctbl(2,ix)=cellfun(@(x,y) sprintf(<span class="string">'%s'</span>,CPRINTF_repmat(x,[1,y])),ctbl(2,ix),num2cell(fmts(ix)),<span class="string">'uni'</span>,false);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	any(~ix)
		spc=<span class="string">' '</span>;
		fmts=fmts-in;
	<span class="keyword">if</span>	par.hasopt.la
		ctbl(2,~ix)=cellfun(@(x,y) [sprintf(<span class="string">'%s'</span>,x),spc(ones([1,y]))],ctbl(2,~ix),num2cell(fmts(~ix)),<span class="string">'uni'</span>,false);
	<span class="keyword">else</span>
		ctbl(2,~ix)=cellfun(@(x,y) [spc(ones([1,y])),sprintf(<span class="string">'%s'</span>,x)],ctbl(2,~ix),num2cell(fmts(~ix)),<span class="string">'uni'</span>,false);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		par.hasopt.Lcs=true;
		par.opt.Lcs=cat(2,ctbl{2,:});
	<span class="keyword">end</span>
<span class="comment">% - table name always left aligned</span>
	<span class="keyword">if</span>	par.hastbl(1)				&amp;&amp;<span class="keyword">...</span>
		par.hastbl(2)
	<span class="keyword">if</span>	par.hasopt.Lh
		hdr=par.opt.Lh{1};
	<span class="keyword">elseif</span>	~isempty(ctbl{1,1})
		hdr=ctbl{1,1};
	<span class="keyword">end</span>
		lfmt=sprintf(<span class="string">'%%-%d.%ds'</span>,par.fmts(1),par.fmts(1));
		ctbl(1,1)={sprintf(lfmt,hdr)};
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%		formatting routines</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	res=CPRINTF_other(varargin)

<span class="comment">% default output for non-scalar CELLs</span>

		res=cell(nargin,1);

	<span class="keyword">for</span>	i=1:nargin
		t=varargin{i};
<span class="comment">% - numeric/logical data type</span>
	<span class="keyword">if</span>	isnumeric(t)				||<span class="keyword">...</span>
		islogical(t)
		w=whos(<span class="string">'t'</span>);
		siz=sprintf(<span class="string">'%dx'</span>,w.size);
		siz(end)=<span class="string">''</span>;
	<span class="keyword">switch</span>	w.class
	<span class="keyword">case</span>	<span class="string">'logical'</span>
		res{i}=sprintf(<span class="string">'L(%d:%s'</span>,numel(w.size),siz);
	<span class="keyword">otherwise</span>
		res{i}=sprintf(<span class="string">'N(%d:%s:%s'</span>,numel(w.size),siz,w.class);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	w.global
		res{i}=sprintf(<span class="string">'%s.g'</span>,res{i});
	<span class="keyword">end</span>
	<span class="keyword">if</span>	w.sparse
		res{i}=sprintf(<span class="string">'%s.s'</span>,res{i});
	<span class="keyword">end</span>
	<span class="keyword">if</span>	w.complex
		res{i}=sprintf(<span class="string">'%s.c'</span>,res{i});
	<span class="keyword">end</span>
		res{i}=sprintf(<span class="string">'%s)'</span>,res{i});

<span class="comment">% - other data type</span>
	<span class="keyword">else</span>
	<span class="keyword">switch</span>	class(t)
	<span class="keyword">case</span>	{<span class="string">'cell'</span>,<span class="string">'struct'</span>}
		w=whos(<span class="string">'t'</span>);
		siz=sprintf(<span class="string">'%dx'</span>,w.size);
		siz(end)=<span class="string">''</span>;
		res{i}=sprintf(<span class="string">'%c(%d:%s)'</span>,upper(w.class(1)),numel(w.size),siz);
	<span class="keyword">case</span>	<span class="string">'function_handle'</span>
		fn=func2str(t);
	<span class="keyword">if</span>	~(fn(1)==<span class="string">'@'</span>)
		fn=sprintf(<span class="string">'@%s'</span>,fn);
	<span class="keyword">end</span>
		res{i}=sprintf(<span class="string">'F(%s)'</span>,fn);
	<span class="keyword">otherwise</span>
		w=whos(<span class="string">'t'</span>);
		siz=sprintf(<span class="string">'%dx'</span>,w.size);
		siz(end)=<span class="string">''</span>;
		res{i}=sprintf(<span class="string">'O(%d:%s:%s)'</span>,numel(w.size),siz,w.class);
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">end</span>

	<span class="keyword">if</span>	nargin == 1
		res=res{i};
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[t,par]=CPRINTF_char(par,t)

		ic=find(par.in);
	<span class="keyword">if</span>	par.hasopt.ce				<span class="comment">% hidden option</span>
		ix=~cellfun(@isempty,t(ic));
	<span class="keyword">if</span>	any(ix)
		t=CPRINTF_cell(par,t,ic(ix),par.opt.c);
	<span class="keyword">end</span>
	<span class="keyword">else</span>
		t=CPRINTF_cell(par,t,ic,par.opt.c);
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[t,par]=CPRINTF_empty(par,t,fpar,varargin)

		vfmt=fpar{1,2};
		fun=fpar{1,5};

		isval=cellfun(fun,t);
	<span class="keyword">if</span>	any(isval)
<span class="comment">% keep empty CHARs</span>
		isval=isval&amp;~cellfun(@ischar,t);
		isval=find(isval);
		[t,par]=CPRINTF_cell(par,t,isval,vfmt{1});
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[t,par]=CPRINTF_logical(par,t,fpar,varargin)

		vfmt=fpar{1,2};
		fun=fpar{1,5};

		isval=cellfun(fun,t);
	<span class="keyword">if</span>	any(isval)

		ixt=find(isval);
		ixfv=cellfun(@(x) x==false,t(ixt));

	<span class="keyword">if</span>	any(ixt(ixfv))
		[t,par]=CPRINTF_cell(par,t,ixt(ixfv),vfmt{1});
	<span class="keyword">end</span>
	<span class="keyword">if</span>	any(ixt(~ixfv))
		[t,par]=CPRINTF_cell(par,t,ixt(~ixfv),vfmt{2});
	<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[t,par]=CPRINTF_naninf(par,t,fpar,varargin)

	<span class="keyword">if</span>	~par.hasopt.ninf
		<span class="keyword">return</span>;
	<span class="keyword">end</span>
	<span class="keyword">if</span>	isempty(varargin)
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

		vfmt=fpar{1,2};
		fun=fpar{1,5};

		isval=cellfun(fun,t);
	<span class="keyword">if</span>	any(isval)

		isval=find(isval);
		isn=cellfun(@isnan,t(isval));
		isi=cellfun(@isinf,t(isval));

	<span class="keyword">if</span>	par.hasopt.N
	<span class="keyword">if</span>	any(isn)
		[t,par]=CPRINTF_cell(par,t,isval(isn),vfmt{1});
	<span class="keyword">end</span>
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hasopt.I
	<span class="keyword">if</span>	any(isi)
		[t,par]=CPRINTF_cell(par,t,isval(isi),vfmt{2});
	<span class="keyword">end</span>
	<span class="keyword">end</span>

	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[t,par]=CPRINTF_number(par,t,fpar,varargin)

		vfmt=fpar{1,2};
		fun=fpar{1,5};

		isval=cellfun(fun,t);
	<span class="keyword">if</span>	any(isval)

	<span class="keyword">if</span>	~isempty(fpar{4})
		isval=reshape(isval,[par.pr,par.pc]);
		db=fpar{4};
	<span class="keyword">if</span>	any(sign(db) &lt; 0)
		db=abs(db);
	<span class="keyword">if</span>	db(1:2)
		isval(db(1):db(2),:)=false;
	<span class="keyword">end</span>
	<span class="keyword">if</span>	db(3:4)
		isval(:,db(3):db(3))=false;
	<span class="keyword">end</span>
	<span class="keyword">else</span>
		isval(db(1):db(2),db(3):db(4))=false;
	<span class="keyword">end</span>
		isval=isval(:);
	<span class="keyword">end</span>

<span class="comment">% sparse</span>
	<span class="keyword">if</span>	par.type.sparse
		paro=par;
		paro.type.sparse=false;
		in=reshape(isval,[paro.pr,paro.pc]);
		in(:,end)=false;
		par.nmod=2;
		[t,par]=CPRINTF_cell(par,t,find(in),paro.opt.s);
	<span class="keyword">if</span>	~any(par.hastbl)
		t=reshape(t,[par.pr,par.pc]);
		t(:,2)=[];
		t=t(:);
		par.pc=par.pc-1;
	<span class="keyword">else</span>
		t=reshape(t,[par.pr,par.pc]);
		t(par.hastbl(1)+1:end,par.hastbl(2)+2)=t(par.hastbl(1)+1:end,par.hastbl(2)+3);
		t(:,end)=[];
		t=t(:);
		par.pc=par.pc-1;
	<span class="keyword">end</span>
		isval=cellfun(fun,t);
		par.in=isval(:);
	<span class="keyword">end</span>

<span class="comment">% real and/or complex</span>
		ixcv=~cellfun(@isreal,t(isval));
		par.nmod=1;
<span class="comment">% real only</span>
	<span class="keyword">if</span>	~any(ixcv)
		[t,par]=CPRINTF_naninf(par,t,par.fpar(2,:),1);
		[t,par]=CPRINTF_cell(par,t,find(isval&amp;par.in),vfmt{1});
<span class="comment">% complex</span>
	<span class="keyword">else</span>
		ixr=find(isval);
		ixc=ixr;
		ixr=ixr(~ixcv);
		ixc=ixc(ixcv);
		paro=par;
		rfmt=[0,0];
<span class="comment">% - real part</span>
	<span class="keyword">if</span>	~isempty(ixr)
		paro.in=true(size(ixr));
		[t(ixr),paro]=CPRINTF_naninf(paro,t(ixr),par.fpar(2,:),2);
		[t(ixr),paro]=CPRINTF_cell(paro,t(ixr),find(paro.in),vfmt{1});
		par.in(ixr)=false;
		rfmt(1)=max(cellfun(@numel,t(ixr)));
	<span class="keyword">end</span>
<span class="comment">% - complex part</span>
		tn=cat(1,t{ixc});
		tr=real(tn);
		ti=imag(tn);
		tt=num2cell([tr,ti]);
		spc=<span class="string">' '</span>;
		vfmt={par.opt.cr,par.opt.ci};
		mfmt=zeros(1,2);

	<span class="keyword">for</span>	i=1:2
		paro.in=true(size(tt,1),1);
		[tt(:,i),paro]=CPRINTF_naninf(paro,tt(:,i),par.fpar(2,:),3);
		[tt(:,i),paro]=CPRINTF_cell(paro,tt(:,i),find(paro.in),vfmt{i});
		mfmt(i)=max(cellfun(@numel,tt(:,i)));
		mfmt(i)=max([mfmt(i),rfmt(i)]);
	<span class="keyword">if</span>	par.hasopt.cla
		tt(:,i)=cellfun(@(x) [x,spc(ones(1,mfmt(i)-numel(x)))],tt(:,i),<span class="string">'uni'</span>,false);
	<span class="keyword">else</span>
		tt(:,i)=cellfun(@(x) [spc(ones(1,mfmt(i)-numel(x))),x],tt(:,i),<span class="string">'uni'</span>,false);
	<span class="keyword">end</span>
	<span class="keyword">end</span>

		z=spc(ones([1,mfmt(2)]));
	<span class="keyword">if</span>	par.hasopt.cla
		t(ixr)=cellfun(@(x) [x,spc(ones(1,mfmt(1)-numel(x)))],t(ixr),<span class="string">'uni'</span>,false);
	<span class="keyword">else</span>
		t(ixr)=cellfun(@(x) [spc(ones(1,mfmt(1)-numel(x))),x],t(ixr),<span class="string">'uni'</span>,false);
	<span class="keyword">end</span>
		t(ixr)=cellfun(@(x) [x,par.opt.cd,z],t(ixr),<span class="string">'uni'</span>,false);
		t(ixc)=cellfun(@(x,y) [x,par.opt.cd,y],tt(:,1),tt(:,2),<span class="string">'uni'</span>,false);
		par.in(ixc)=false;
		par.sconv=paro.sconv;
	<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[t,par]=CPRINTF_cell(par,t,ix,fmt)

	<span class="keyword">if</span>	isempty(ix)
		<span class="keyword">return</span>;
	<span class="keyword">else</span>
		ix=ix(:).';
	<span class="keyword">end</span>

		fmtc=class(fmt);

	<span class="keyword">switch</span>	par.nmod
<span class="comment">% full numbers</span>
	<span class="keyword">case</span>	1
		<span class="keyword">switch</span>	fmtc
		<span class="keyword">case</span>	<span class="string">'char'</span>
		<span class="keyword">for</span>	i=ix
      <span class="keyword">if</span> isnumeric(t{i}) &amp;&amp; t{i}==0, t{i}=0;<span class="keyword">end</span>
			t{i}=sprintf(fmt,t{i});
		<span class="keyword">end</span>
		<span class="keyword">case</span>	<span class="string">'function_handle'</span>
		<span class="keyword">for</span>	i=ix
			t{i}=fmt(t{i});
		<span class="keyword">end</span>
		<span class="keyword">otherwise</span>
			error(<span class="string">'%s&gt; invalid format %s'</span>,par.magic,upper(fmtc));
		<span class="keyword">end</span>
<span class="comment">% sparse numbers</span>
	<span class="keyword">case</span>	2
			nx=numel(ix)/2;
		<span class="keyword">switch</span>	fmtc
		<span class="keyword">case</span>	<span class="string">'char'</span>
		<span class="keyword">for</span>	i=1:nx
			ca=ix(i);
			cb=ix(i+nx);
			t{ca}=sprintf(fmt,t{ca},t{cb});
		<span class="keyword">end</span>
		<span class="keyword">case</span>	<span class="string">'function_handle'</span>
		<span class="keyword">for</span>	i=1:nx
			ca=ix(i);
			cb=ix(i+nx);
			t{ca}=fmt(t{ca},t{cb});
		<span class="keyword">end</span>
		<span class="keyword">otherwise</span>
			error(<span class="string">'%s&gt; invalid format %s'</span>,par.magic,upper(fmtc));
		<span class="keyword">end</span>
<span class="comment">% other data types</span>
	<span class="keyword">case</span>	3
		<span class="keyword">for</span>	i=ix
			res=fmt(t{i});
		<span class="keyword">if</span>	par.hasopt.Or
			res=res(3:end-1);
		<span class="keyword">end</span>
			t{i}=res;
		<span class="keyword">end</span>
	<span class="keyword">otherwise</span>
		error(<span class="string">'%s&gt; invalid print mode %d'</span>,par.magic,par.nmod);
	<span class="keyword">end</span>

<span class="comment">% reset flag to NUMBERS</span>
		par.nmod=1;
<span class="comment">% update counters</span>
		par.in(ix)=false;
		par.sconv=par.sconv+numel(ix);
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="comment">%		file io routines</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	varargout=CPRINTF_ascii2file(varargin)

<span class="comment">% MACRO call</span>
<span class="comment">% NOTE:	table mode turned off by default</span>
<span class="comment">%	quiet mode turned on  by default</span>

	<span class="keyword">if</span>	nargout
		[varargout{1:nargout}]={[]};
	<span class="keyword">end</span>
	<span class="keyword">if</span>	nargin &gt; 1
		opt=CPRINTF_parse_option(0,varargin{2:end});
	<span class="keyword">if</span>	isfield(opt,<span class="string">'fc'</span>)			||<span class="keyword">...</span>
		isfield(opt,<span class="string">'fa'</span>)
		[varargout{1:nargout}]=cprintf(varargin{1},<span class="string">'-mt'</span>,0,<span class="string">'-q'</span>,1,varargin{2:end});
		<span class="keyword">return</span>;
	<span class="keyword">end</span>
	<span class="keyword">end</span>
		disp(<span class="string">'CPRINTF.write&gt; must have a [-fc] or [-fa] option/value pair'</span>);
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[ctbl,par]=CPRINTF_write(par,ctbl)

	<span class="keyword">if</span>	~par.hasopt.fa				&amp;&amp;<span class="keyword">...</span>
		~par.hasopt.fc
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

		odisp=par.disp;
	<span class="keyword">if</span>	par.hasopt.q
		par.disp=@CPRINTF_nodisp;
	<span class="keyword">else</span>
		par.disp=@CPRINTF_disp;
	<span class="keyword">end</span>

<span class="comment">% writing mode</span>
		fout=[];
	<span class="keyword">if</span>	par.hasopt.fc
		wmod=<span class="string">'wt'</span>;
		wspec=<span class="string">'create'</span>;
		fout=par.opt.fc;
	<span class="keyword">end</span>
	<span class="keyword">if</span>	par.hasopt.fa
		wmod=<span class="string">'at'</span>;
		wspec=<span class="string">'append'</span>;
		fout=par.opt.fa;
	<span class="keyword">end</span>
	<span class="keyword">if</span>	isempty(fout)
		par.disp(<span class="string">'CP| no name   : %10s   %s'</span>,<span class="string">' '</span>,<span class="string">'[-fc] and [-fa] options empty'</span>);
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

<span class="comment">% check</span>
<span class="comment">% - token replacement</span>
<span class="comment">% - file  insertion</span>
	<span class="keyword">if</span>	par.hasopt.fi

		[fp,emsg]=fopen(par.opt.fi,<span class="string">'rt'</span>);
	<span class="keyword">if</span>	fp &lt; 0
		error(<span class="string">'%s&gt; cannot access input file %s\n%s'</span>,par.magic,par.opt.fi,emsg);
	<span class="keyword">end</span>

<span class="comment">%   faster than textread/textscan</span>
		[otxt,nchar]=fread(fp,<span class="string">'*char'</span>);
		fclose(fp);
	<span class="keyword">if</span>	nchar
		otxt=strread(otxt.',<span class="string">'%s'</span>,<span class="string">'delimiter'</span>,<span class="string">'\n'</span>,<span class="string">'whitespace'</span>,<span class="string">''</span>);
	<span class="keyword">else</span>
		otxt=<span class="string">''</span>;
	<span class="keyword">end</span>

	<span class="keyword">if</span>	par.hasopt.fr
		ntxt=regexprep(otxt,par.opt.fr(:,1:2:end),par.opt.fr(:,2:2:end));
	<span class="keyword">else</span>
		ntxt=otxt;
	<span class="keyword">end</span>

	<span class="keyword">if</span>	par.hasopt.fm
		ix=regexp(ntxt,par.opt.fm);
		ic=cellfun(@(x) all(~isempty(x)&amp;&amp;x==1),ix);
	<span class="keyword">if</span>	any(ic)
		wmod=<span class="string">'wt'</span>;
		wspec=<span class="string">'create'</span>;
		ic=find(ic,1,<span class="string">'first'</span>);
		ntxt(ic)={ctbl};
	<span class="keyword">elseif</span>	par.hasopt.fa
		wmod=<span class="string">'at'</span>;
		ntxt=[ntxt;{ctbl}];
	<span class="keyword">else</span>
		error(<span class="string">'%s&gt; marker %s not found in file template %s'</span>,par.magic,par.opt.fm,par.opt.fi);
	<span class="keyword">end</span>
	<span class="keyword">end</span>

		par.disp(<span class="string">'CP| template  : %10s   %s'</span>,<span class="string">' '</span>,par.opt.fi);
	<span class="keyword">else</span>
		ntxt={ctbl};
	<span class="keyword">end</span>

<span class="comment">% write/append output file</span>
	<span class="keyword">if</span>	~isempty(ntxt)
		ntxt=char(ntxt);
		nspc=size(ntxt,1);
		ntxt=[ntxt,repmat(sprintf(<span class="string">'\n'</span>),nspc,1)];

		[fp,msg]=fopen(fout,wmod);
	<span class="keyword">if</span>	fp &gt; 0
		r=fwrite(fp,ntxt.',<span class="string">'char'</span>);
		fclose(fp);
		par.disp(<span class="string">'CP| %8s  : %10d b %s'</span>,wspec,r+nspc,fout);
	<span class="keyword">else</span>
		error(<span class="string">'%s&gt; cannot write/append file %s\n%s'</span>,par.magic,fout,msg);
	<span class="keyword">end</span>
	<span class="keyword">end</span>

		par.disp(<span class="string">' '</span>);
		par.disp=odisp;
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[res,copt]=CPRINTF_ini2opt(par,varargin)

		mflg=false;
		copt=par;

	<span class="keyword">if</span>	~isstruct(par)
		mflg=true;
		par=cprintf;
		par=CPRINTF_parse_option(par,varargin{:});
	<span class="keyword">end</span>

		odisp=par.disp;
	<span class="keyword">if</span>	par.hasopt.q
		par.disp=@CPRINTF_nodisp;
	<span class="keyword">else</span>
		par.disp=@CPRINTF_disp;
	<span class="keyword">end</span>

		narg=numel(varargin);
	<span class="keyword">if</span>	narg &lt; 1				||<span class="keyword">...</span>
		isempty(varargin{1})			||<span class="keyword">...</span>
		~ischar(varargin{1})
	<span class="keyword">if</span>	nargout
		res.nop=true;
		copt.nop=false;
	<span class="keyword">end</span>
		<span class="keyword">return</span>;
	<span class="keyword">end</span>

<span class="comment">% file id</span>
		ihdr=sprintf(<span class="string">'%%%s\toption file'</span>,par.magic);
		ilen=numel(ihdr);
		isec=sprintf(<span class="string">'%%%%%%\tsection ----------- %s ---------- user data'</span>,par.magic);
		nopt=3;
<span class="comment">% rex engine</span>
		rex=<span class="string">'(?&lt;=(''-))[^-\d+]\w*(?!=,)'</span>;
		id=sprintf(<span class="string">'tcp_%s'</span>,num2hex(rand(1,3)).');
		idc=<span class="string">'''-'''</span>;

		fnam=which(varargin{1});
	<span class="keyword">if</span>	~exist(fnam,<span class="string">'file'</span>)
		error(<span class="string">'%s&gt; ini file not found %s'</span>,par.magic,fnam);
	<span class="keyword">end</span>

	<span class="keyword">if</span>	narg &gt; 1				&amp;&amp;<span class="keyword">...</span>
		~isempty(varargin{2})			&amp;&amp;<span class="keyword">...</span>
		ischar(varargin{2})
		kflg=true;
		fini=varargin{2};
		fout=fini;
		[fini,fini]=fileparts(fini);
	<span class="keyword">else</span>
		kflg=false;
		fini=id;
		fout=<span class="string">'temporary file removed'</span>;
	<span class="keyword">end</span>
		fini=sprintf(<span class="string">'%s.m'</span>,fini);

		[fp,msg]=fopen(fnam,<span class="string">'rt'</span>);
	<span class="keyword">if</span>	fp &lt; 0
		error(<span class="string">'%s&gt; cannot open ini file %s\n'</span>,par.magic,fnam,msg);
	<span class="keyword">end</span>
		d=fread(fp,inf,<span class="string">'uint8=&gt;char'</span>);
		fclose(fp);
		d=d(:).';

	<span class="keyword">if</span>	strncmp(d,ihdr,ilen) == 1
<span class="comment">% old ini file</span>
		[topt,par]=CPRINTF_readini(par,fnam);
		nent=numel(fieldnames(topt))-nopt;

		fold=sscanf(d(ilen+2:end),<span class="string">'%[^\n]'</span>);
		d=strread(d,<span class="string">'%s'</span>,<span class="string">'delimiter'</span>,<span class="string">'\n'</span>,<span class="string">'whitespace'</span>,<span class="string">''</span>);
		ix=find(strcmp(d,isec));
	<span class="keyword">if</span>	numel(ix) &lt; 2
		error(<span class="string">'%s&gt; invalid ini file %s'</span>,par.magic,fnam);
	<span class="keyword">end</span>
		par.disp(<span class="string">'CP| header    : %10s   %s'</span>,<span class="string">' '</span>,fold);
		par.disp(<span class="string">'CP| file      : %10d   %s'</span>,nent,fnam);
		res=d(ix(1)+1:ix(2)-1);

	<span class="keyword">else</span>
<span class="comment">% new ini file</span>
		par.disp(<span class="string">'CP| file      : %10s   %s'</span>,<span class="string">' '</span>,fnam);

		d=strrep(d,idc,id);
		d=regexprep(d,<span class="string">'(\s*,\s*)'</span>,<span class="string">','</span>);
		d=regexprep(d,<span class="string">'(\s*;\s*)'</span>,<span class="string">';'</span>);
		d=regexprep(d,<span class="string">',{2,}'</span>,<span class="string">','</span>);

		[ftok,fbeg,fend]=regexp(d,rex,<span class="string">'match'</span>,<span class="string">'start'</span>,<span class="string">'end'</span>);
	<span class="keyword">if</span>	isempty(ftok)
		error(<span class="string">'%s&gt; no options found in %s'</span>,par.magic,fnam);
	<span class="keyword">end</span>
		fend(end+1)=nan;
		fbeg(end+1)=numel(d)+3;
		ntok=numel(fend)-1;
		ctok=cell(ntok,1);

	<span class="keyword">for</span>	i=1:ntok
		stok=d(fend(i)+3:fbeg(i+1)-3);
	<span class="keyword">if</span>	isempty(stok)
		stok=<span class="string">'[]'</span>;
	<span class="keyword">else</span>
		stok=regexprep(stok,<span class="string">'(\n+$)'</span>,<span class="string">''</span>);
		stok=regexprep(stok,<span class="string">'[,;]+$'</span>,<span class="string">''</span>);
	<span class="keyword">end</span>
		ctok(i)={stok};
	<span class="keyword">end</span>
		ctok=strrep(ctok,id,idc);

<span class="comment">% add ID</span>
		ftok=[
			<span class="string">'magic'</span>
			<span class="string">'ver'</span>
			<span class="string">'MLver'</span>
			ftok.'
		];
		ctok=[
			{
			sprintf(<span class="string">'''%s'''</span>,par.magic)
			sprintf(<span class="string">'''%s'''</span>,par.ver)
			sprintf(<span class="string">'''%s'''</span>,version)
			}
			ctok
		];

		nent=numel(unique(ftok))-nopt;
		ns=max([2;cellfun(@numel,ftok)]);
		fmt=sprintf(<span class="string">'\\to.%%%d.%ds = %%s;'</span>,ns,ns);
		res=cellfun(@(x,y) sprintf(fmt,x,y),ftok,ctok,<span class="string">'uni'</span>,false);
	<span class="keyword">end</span>

<span class="comment">% create INI file</span>
		hdr={
		sprintf(<span class="string">'%s %s'</span>,ihdr,fini)
		sprintf(<span class="string">'%%version	%s'</span>,par.ver)
		sprintf(<span class="string">'%%created	%s'</span>,datestr(clock))
		sprintf(<span class="string">'%%options	%-1d unique/user defined'</span>,nent)
		sprintf(<span class="string">'%%'</span>)
		sprintf(<span class="string">'%%SYNTAX		opt = %s;'</span>,fini)
		sprintf(<span class="string">''</span>)
		sprintf(<span class="string">'function\to = %s(varargin)\n'</span>,fini(1:end-2))
		isec
		};
		ftr={
		isec
		sprintf(<span class="string">'end'</span>)
		};
		mc=max(cellfun(@numel,hdr(1:8)));
		hdr{7,1}=sprintf([<span class="string">'%%'</span>,repmat(<span class="string">'-'</span>,1,mc-2+8)]);	<span class="comment">% 1 TAB</span>

		par.disp(<span class="string">'CP| create    : %10s   %s'</span>,<span class="string">' '</span>,fout);

		[fp,msg]=fopen(fini,<span class="string">'wt'</span>);
	<span class="keyword">if</span>	fp &lt; 3
		error(<span class="string">'%s&gt; cannot create ini file %s'</span>,par.magic,fini,msg);
	<span class="keyword">end</span>
		fprintf(fp,<span class="string">'%s\n'</span>,hdr{:});
		fprintf(fp,<span class="string">'%s\n'</span>,res{:});
		fprintf(fp,<span class="string">'%s\n'</span>,ftr{:});
		fclose(fp);

<span class="comment">% read INI file</span>
		[res,par]=CPRINTF_readini(par,fini);
		par.disp(<span class="string">'CP| options   : %10d   %s'</span>,<span class="keyword">...</span>
			numel(fieldnames(res))-nopt,<span class="string">'unique/user defined'</span>);

<span class="comment">% clean up</span>
	<span class="keyword">if</span>	~kflg
		delete(fini);
	<span class="keyword">end</span>
	<span class="keyword">if</span>	~nargout
		clear <span class="string">res</span>;
	<span class="keyword">elseif</span>	mflg
		copt=CPRINTF_struct2opt(0,res);
	<span class="keyword">end</span>

		par.disp(<span class="string">' '</span>);
		par.disp=odisp;
<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span>
<span class="keyword">function</span>	[res,par]=CPRINTF_readini(par,fini)


		[fpat,frot]=fileparts(fini);
	<span class="keyword">if</span>	~isempty(fpat)
		ocd=cd(fpat);
	<span class="keyword">else</span>
		ocd=cd;
	<span class="keyword">end</span>
		res=feval(frot);
		cd(ocd);

<span class="keyword">end</span>
<span class="comment">%-------------------------------------------------------------------------------</span></pre><pre class="codeoutput"> CPRINTF	convert an array of any data type to a 2D character array
 
 		- converts an ND array of any MATLAB data type
 		  to a 2D character array
 		- the input may be a cell array formatted as a table with
 		  row/column labels and row/column separators
 		- any input can be formatted as a table using
 		  any combination of
 		  row/column labels and row/column separators
 		- the result may be written/appended to an ASCII file or
 		  inserted at a user marked position
 
 		  see also: sprintf, fprintf, printmat, cphelp, setpref
 
 SYNTAX
 -------------------------------------------------------------------------------
 		[T,TC,AC,P] = CPRINTF(A,OPT1,...,OPTn)
 				converts A
 		 P          = CPRINTF
 				returns  the engine parameters
 		              CPRINTF
 				displays the help
 
 INPUT
 -------------------------------------------------------------------------------
  A	:	an ND array of
   		- real and/or complex full   numeric data
   		- real and/or complex sparse numeric data
   		- logical data
   		- char strings
 		- structures
   		- other objects
   		an ND cell array of any combination of the above
 
  OPTION	argument	description		default
  ----------------------------------------------------------------
 		SC		a single CHAR
 		CS		a CHAR string
 		FS		a format spec
  ----------------------------------------------------------------
  CELL				data type
  ----------------------------------------------------------------
     -c	:	FS		character string	'%s'
     -n	:	FS		numeric real		'%g'
    -cr	:	FS		numeric complex real	'%g'
    -ci	:	FS		numeric complex imag	'%+gi'
    -cd	:	FS		numeric complex delim	' '
     -s	:	FS		numeric sparse indices	'(%g %g)'
     -f	:	FS		false			'F'
     -t	:	FS		true			'T'
     -E	:	FS		empty CELL		'E(class)'
     -I	:	FS		&#65533;Inf			'&#65533;INF'
     -N	:	FS		NaN			'NAN'
    -hs	:	T|F		convert to single hex	[F]
    -hd	:	T|F		convert to double hex	[F]
   -nex	:	T|F		no char CELL expansion	[F]
     -O	:	FS		other objects		[built-in]
    -Or	:	T|F		other objects raw mode	[built-in]
     -C	:	FS		text surrounding CELLs	'%s'
    -la	:	T|F		cell content alignment	[F]
   -cla	:	T|F		complex alignment	[F]
 				F = right align
 				T = left  align
 
  ROW				content
  ----------------------------------------------------------------
     -L	:	CS		leading   row text	''
     -T	:	CS		trailing  row text	''
     -d	:	SC		separator between CELLs	' '
    -dt	:	SC		separator table columns	' '
    -nd	:	T|F		show ND page indices	[F]
 
  TABLE				content / processing
  ----------------------------------------------------------------
    -Ct	:	FS		text surrounding body	'%s'
 				but not label CELLs
    -nc	:	FS		numeric real col	'%g'
    -nr	:	FS		numeric real row
    -Lh	:	{tn}		table  name		{' '}
    -Lc	:	{c1...cn}	column labels
    -Lr	:	{r1...rn}	row    labels
   -Lcs	:	SC		column separator	''
   -Lrs	:	SC		row    separator	''
    -it	:	T|F		input is a       table	[F]
    -mt	:	T|F		convert input to table	[F]
    -ic	:	T|F		column width		[F]
 				F = max of all  cols
 				T = max of each col
 
  OUTPUT FILES
  ----------------------------------------------------------------
    -fa	:	name		append to output file	[]
    -fc	:	name		create    output file	[]
    -fi	:	name		input  file		[]
    -fm	:	marker		insert result at marker	[]
 				in file [-fin]
    -fr	:	{t1,r1,...}	replace token tx with	[]
 				value rx
 
  PROCESSING
  ----------------------------------------------------------------
     -p	:	T|F		do NOT use preferences	[F]
   -opt	:	struct		use struct.option	[]
   -ini	:	name		read options from file	[]
   -sav	:	name		save options to   file	[]
   -tab	:	n		use n SPACES/TAB	[8]
  -ntab	:	T|F		keep TABs in CELLs	[F]
     -q	:	n		do not display result	[F]
    -so	:	T|F		collect all output in	[F]
 				a structure
    -db	:	T|F		show processing stages	[F]
 				and timing
 
 OUTPUT
 -------------------------------------------------------------------------------
  T	:	char array with same number of rows and
 		[-d] separated columns as A
  TC	:	cell array of T
  AC	:	cell array of A (useful if A is print as a table)
  P	:	structure with engine parameters
 
 NOTE
 -------------------------------------------------------------------------------
 		- FS a format spec
 		     - a valid SPRINTF/FPRINTF format string
 		     - a function or function handle returning a
 		       character string, eg,
 		       by default, options -E uses the functions
 		       @(x) sprintf('E(%s)',class(x))
 		- by default, other data types are decoded according
 		       to their class (see CPHELP)
 		- by default, CELLs of Mx1 or ND character strings
 		  are expanded unless the [-nex] option is used
 		- all [-Lx] options take a cell of any data type
 		- all [-Lx/-Lxx] options override
 		  preset [-it] or default [-mt] table entries
 		- all [-Lx] label(s) will be repeated or cut
 		  automatically to fit the table size
 		- TC/AC may be used as input into several
 		  spreadsheet applications, eg, xlswrite
 		- at startup, CPRINTF will look for default options set by
 			setpref('cprintf','opt',{OPT1,...,OPTn});
 		     - runtime options will overwrite preferences 
 		     - preferences are preserved between ML sessions
 		- if NO output argument is used, CPRINTF displays
 		  the result even if with a trailing &lt;;&gt;
 
 EXAMPLE
 -------------------------------------------------------------------------------
 	m=reshape(1:3*5,[3,5]);
  %	print M including their binary representation
 	cprintf(m,'-n',@(x) sprintf('%d=%s',x,dec2bin(x,4)),'-d','| ')
  		 1=0001|  4=0100|  7=0111| 10=1010| 13=1101
  		 2=0010|  5=0101|  8=1000| 11=1011| 14=1110
  		 3=0011|  6=0110|  9=1001| 12=1100| 15=1111
 
  %	print M as a table with default labels/separators
 	cprintf(m,'-n',@(x) sprintf('%d=%s',x,dec2bin(x,4)),'-mt',1)
  		  |       1       2       3       4       5
  		-------------------------------------------
  		1 |  1=0001  4=0100  7=0111 10=1010 13=1101
  		2 |  2=0010  5=0101  8=1000 11=1011 14=1110
  		3 |  3=0011  6=0110  9=1001 12=1100 15=1111

</pre><p style="font-size:1px;"></p>
         <table class="footer" border="0" width="100%" cellpadding="0" cellspacing="0">
            <tr>
               <td valign="baseline" align="right">DocHelp 0.1 beta</td>
            </tr>
         </table><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83346204-1', 'auto');
  ga('send', 'pageview');

   </script></div>
   </body>
</html>